{"meta":{"title":"seokwon","subtitle":"Seokwon}.github.io","description":"seokwon's blog","author":"seokwon","url":"https://wonn223.github.io"},"pages":[],"posts":[{"title":"코드스피츠 수업 정리 - OOP(0.5..?)","slug":"OOP","date":"2018-01-28T07:20:11.000Z","updated":"2018-01-28T07:20:11.000Z","comments":true,"path":"2018/01/28/OOP/","link":"","permalink":"https://wonn223.github.io/2018/01/28/OOP/","excerpt":"","text":"6기 분들이 소개해 준 객체지향 책을 접하고 나서 객체지향과 관련된 강의를 찾아봤다. 아래 강의는 JSON파일을 화면에 표현하는 작업을 예시로 es6와 객체지향을 결합한 코딩을 보여준다. 강의를 들으면서 정리해봤다. 코드 스피츠71 - 디자인 패턴 1회차 중 기본 코드아래는 json을 불러와서 &lt;table&gt;요소에 표현하는 기본 코드다. 12345678910const Table =(_=&gt;&#123; const Private = Symbol(); return class&#123; constructor(parent)&#123;&#125; async load(url)&#123;&#125; _render()&#123;&#125;&#125;; &#125;)();const table = new Table(&quot;#data&quot;);table.load(&quot;71_1.json&quot;); 즉시실행함수를 구현한 이유는 파서가 코드를 읽을 때 const 변수에 값이 할당시키려는 데 있다. const는 초기화 과정에 값이 반드시 있어야 하기 때문에 클래스를 리턴하는 함수를 만들었다. 즉시실행함수를 쓰게 되면 클래스 인스턴스끼리 공유하는 private/static한 변수를 자바스크립트 스타일로 구현할 수 있다. 자바스크립트에서 private 변수 구현하기123456789101112131415161718인자 자리에 언더스코어(_) 식별자가 들어갔다.const Table = (_=&gt; &#123; &lt;!-- 자유 변수 공간 --&gt; const render = Symbol(&apos;render&apos;); const Private = Symbol(&apos;Private&apos;); &lt;!-- private, static공간 --&gt; return class &#123; constructor(parent)&#123; if(typeof parent != &apos;string&apos; || !parent ) throw &apos;invalid param&apos;; &lt;!-- 심볼은 반드시 대괄호. 심볼은 키를 대신 할 수 있다. --&gt; this[Private] = &#123; parent &#125; console.log(this[Private]); &#125; (이하 생략...) 우선 함수의 리턴값을 함수로 만들어서 그 사이에 자유 변수 공간을 만들었다. 변수 const render와 const Private가 선언된 공간이 자유 변수 공간인데, 이 공간의 변수는 아래 클래스 내부에서만 참조할 수 있다. 물론 외부에서 프로퍼티 키를 읽는 메소드를 쓰면, 이 공간의 변수를 조회할 수 있다. 하지만 변수를 직접 참조하긴 어렵다. 자유변수의 변수에 프리머티브한 값인 심볼을 할당해서 보다 더 private한 성격을 가지게 했다. 각각의 심볼은 전체 어플리케이션에서 유일하기 때문에 중복으로 인한 부작용을 막을 수 있다. validation 습관을 들이자. 컨스트럭터 내부를 보면 validation 코드가 있다. 여기서 검증을 하는 이유는 런타임 동안 인자로 들어오는 객체에 오류가 없는지 확인하는 데 있다. 런타임엔 스택에 코드가 연쇄적으로 쌓이는데, 이렇게 되면 오류가 났을 때 문제가 처음 어디서 발생했는지 찾기 어렵다. 그래서 throw에러를 쓰면 에러 발생의 첫 지점을 분명하게 보여줄 수 있다. 프로미즈를 활용한 load12345678910&lt;!-- url로 데이터 가져오기 --&gt;load(url) &#123; fetch(url).then(res =&gt; &#123; return res.json() &#125;).then(json =&gt; &#123; &lt;!-- 둘 중 하나 --&gt; this._render() || this[render](); &#125;) &#125;[render]()&#123;&#125; fetch는 브라우저 내장API로 AJAX(XHR객체)를 대체할 수 있다. 프로미즈를 반환값으로 줘서 프로미즈 메소드then을 사용할 수 있다. this[render]는 심볼을 가진 객체를 키로 접근하는 코드다. 심볼값이 있기 때문에 대괄호를 쓴다. arrow 함수의 this는 load 메소드를 감싸고 있는 바깥 영역의 스코프를 가진다. 그래서 this[render]에 접근 가능하다. function 키워드는 es6에서 사용하지 않는다. 클래스 메소드나 애로우 함수로 표현 가능하다. function을 쓰면 브라우저가 호환모드로 인식해서 속도가 늦어진다. es6를 목표로 한다면 es6 문법을 최대한 써보도록 노력해야한다. async/await 활용하기1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556async [load](url) &#123; const response = await window.fetch(url); if(!response.ok) throw &quot;invalid response&quot;; const json = await response.json(); const &#123; title, header, items &#125; = json; if(!items.length) throw &quot;no items&quot;; Object.assign(this[Private], &#123;title, header, items&#125;); return this[render](); &#125; [render]()&#123; const fields = this[Private], parent = document.querySelector(fields.parent); &lt;!-- validation --&gt; if(!parent) throw &quot;invalid parent&quot;; if(!fields.items || !fields.items.length) &#123; parent.innerHTML = &quot;no data&quot; return; &#125; else parent.innerHTML = &apos;&apos;; &lt;!-- table 노드 생성 --&gt; const table = document.createElement(&quot;table&quot;); &lt;!-- caption 노드 - table 노드 뒤 선언해야한다. --&gt; const caption = document.createElement(&quot;caption&quot;); caption.innerHTML = fields.title; table.appendChild(caption); table.appendChild( fields.header.reduce((thead, data) =&gt; &#123; &lt;!-- th 노드 생성 --&gt; const th = document.createElement(&quot;th&quot;); &lt;!-- data할당 --&gt; th.innerHTML = data; thead.appendChild(th); return thead; &#125;, document.createElement(&quot;thead&quot;)) ); &lt;!-- tr요소 생성 후 thead 안으로 추가하기 --&gt; parent.appendChild( fields.items.reduce((table, row) =&gt; &#123; table.appendChild( row.reduce((tr, data) =&gt; &#123; const td = document.createElement(&quot;td&quot;); td.innerHTML = data; tr.appendChild(td); return tr; &#125;, document.createElement(&quot;tr&quot;)) ); return table; &#125;, table) ) &#125; &#125;;&#125;)(); promise보다 async/await가 나은 점, 배열 reduce 메소드비동기를 동기식으로 표현이 간결해졌고, 상태 검증 후 에러 처리가 보다 용이하다. 프로미즈를 썼다면 정확한 오류지점을 파악하려고 .then마다 일일이 .catch를 달아야 한다. async를 쓰면 조건문을 활용한 validation으로 에러를 확인할 수 있다. Array.prototype.reduce()의 장점은 쉽게 하나의 값을 만들 수 있닫는 것이다. reduce를 쓰면 배열의 여러 요소를 하나의 ‘값’으로 만들 수 있다. 두 번째 인자는 초기값을 미리 입력할 수 있는 자리다. 인자에 있는 객체가 여기 있는 초기값을 활용한다. 테이블 태그 관련) thead 요소는 열의 제목으로 구성된 행의 집합으로 caption 다음에 위치해야한다. caption태그도 thead태그 뒤에 위치해야한다. 객체지향에서 바라본 지금까지의 코드 문제점 문제점 1 load(url){}에서 url을 사용한다는 것 자체가 객체지향이 아니다. 객체지향은 객체 간 협력 시 객체를 주고 받아야 하는데, url(즉, json) 값 객체를 주고 받고 있다. 값을 인자로 받고 절차를 구현한다는 건 객체지향에 어긋난다. 문제점 2Table 객체 안에 독립적인 역할과 책임을 가지는 load(), render()가 있다. 분리시킬 필요가 있다. 수정해보기 - 우선, 협력관계를 정한다.객체지향에서 코드를 구현할 때 객체 간의 협력 관계를 잘 정해야 한다. 많은 사람들이 실수하는 것이 데이터 로더와 렌더러가 협력해야한다고 생각하는 것이다. 하지만 정확한 협력 관계는 데이터를 공급하는 데이터 공급자와 렌더러가 협력하는 것이다. 데이터 공급자 객체를 만든다여러 데이터 중 json 데이터를 가지는 JSONData객체를 만든다.1234const data = new JSONData(&apos;77_1.json&apos;);const renderer = new Renderer();renderer.render(data); 표시할 데이터를 가진 JSONData 클래스를 렌더러 메소드의 인자로 넣었다. 이렇게 밀접한 협력이 일어나는 모델을 트랜잭션 모델이라고 한다. 단, Renderer는 동기 함수인데 변수 data는 url로 데이터를 받아오는 과정이 있어 비동기적 처리가 일어난다. 둘의 제어 흐름을 맞추려면, data를 thenable로 만들 수 있는 async/await를 써야한다. 즉, 값이 준비되었을 때 다음 처리가 되게하는 것이다. 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 보다 다양한 데이터를 getData()할 수 있게 인터페이스 선언 --&gt;const Data = class &#123; async getData() &#123; throw &quot;must be overrided&quot;&#125;&#125; &lt;!-- 아래 데이터들이 Data를 상속 --&gt;const JSONData = class extends Data &#123; constructor(data) &#123; super(); &lt;!-- es6에서부턴 this를 사용하려면 super키워드를 사용해야한다. --&gt; this._data = data; &#125; &lt;!-- 오버라이딩 --&gt; async getData()&#123; &lt;!-- validation --&gt; if(typeof this._data == &apos;String&apos;) &#123; const response = await fetch(this._data); return await response.json(); &#125; else return this._data; &#125;&#125;; &lt;!-- 역할 - 리턴받은 data를 뷰에 보여준다. --&gt;const Renderer = class &#123; constructor()&#123;&#125; async render(data)&#123; &lt;!-- validation --&gt; if(!(data instanceOf Data )) throw &apos;sth is missed&apos;; &lt;!-- 통과하면 데이터 받아오기 --&gt; const json = await data.getData(); &#125;&#125; getData()의 리턴값이 thenable이다. async를 쓰는 순간 프로미즈 then처럼 반환값을 프로미즈로 만들어 준다. 이 반환값을 Renderer의 render가 받는다. render(data)에서 instanceOf를 사용하는데 이는 객체지향 관점에서 적절한 validation이다. 객체 협력 모델에서는 값을 판정하지 않고 형(type)을 판정하기 때문이다. json이건 아니건 중요한 건 Data type을 가지고 있는지 여부다. 객체지향 관점에서 바라본 렌더러 코드의 문제점 아직 data가 값이다. 객체 협력에서 data가 객체로 넘어가야하는데 값을 주고받고 간단한 형 체크만 하는 형태. 객체지향에서 값의 컨텍스트가 나타나선 안 된다. 처음 브라우저에서 성공적으로 데이터가 나왔지만, 사실 지금 제공한 json데이터는 아래 형 체크에서 오류를 일으킨다. data를 Info객체로 만들어야 함. 1234567891011121314151617181920212223242526272829303132const Info = class &#123; constructor(json)&#123; &lt;!-- json을 받은 후에 디스트럭쳐링해서 오류 여부 체크해보기 --&gt; const &#123; title, header, items &#125; = json; &lt;!-- validation --&gt; &lt;!-- title이 스트링이 아니고 값이 없다면 throw 에러 --&gt; if(title != string || !string) throw &apos;스트링 타입이 유효하지 않거나 값이 없습니다&apos;; &lt;!-- 헤더의 형이 배열인가? --&gt; if(Array.isArray(header) || !header.length ) &apos;헤더 타입이 유효하지 않거나 값이 없습니다&apos; &lt;!-- 아이템의 형이 배열인가? --&gt; if(Array.isArray(items) || !items.length ) &apos;아이템 타입이 유효하지 않거나 값이 없습니다&apos; items.forEach( (item, idx) =&gt; &#123; if(Array.isArray(v) || v.length != header.length) &#123; throw `invalid idx : $&#123;v&#125;` &#125; &#125;); &lt;!-- 위 검증을 다 마치면 변수에 할당 --&gt; this._private = &#123; title, header, items&#125;; &#125; get title() &#123; this.title = this._private.title &#125;; get header() &#123; return this._private.header &#125;; get items() &#123; return this._private.title &#125;;&#125; 이제 Info객체를 활용하면 어떤 종류의 데이터도 안전한 객체로 받아 쓸 수 있다. 안전성도 있다. get이 외부에 노출되는 인터페이스지만, 게터 없이 클래스 내부 변수로 직접 접근 못 한다. 123456789async getData()&#123; validation if(typeof this._data == &apos;String&apos;) &#123; const response = await fetch(this._data); json = await response.json(); 리턴값이 thenable이다. async를 쓰는 순간 프로미즈 then처럼 반환값을 정해준다. &#125; else json = this._data; return new Info(json);&#125;","categories":[],"tags":[{"name":"코드 스피츠, OOP, 객체지향, ES6","slug":"코드-스피츠-OOP-객체지향-ES6","permalink":"https://wonn223.github.io/tags/코드-스피츠-OOP-객체지향-ES6/"}]},{"title":"WeakMap","slug":"weakmap","date":"2018-01-25T12:36:37.000Z","updated":"2018-01-25T12:42:40.000Z","comments":true,"path":"2018/01/25/weakmap/","link":"","permalink":"https://wonn223.github.io/2018/01/25/weakmap/","excerpt":"","text":"WeakMap이 private한 데이터와 메소드를 지켜주는 역할을 하는 걸로 알고 있었는데, 그 외 특징이 무엇인지 알아봤다. Map과 비교해서 보는 WeakMap의 장점(MDN) Map의 인덱스 사용 Map인 객체에서 키/값 쌍을 넣거나 검색할 때, 원하는 검색결과가 나올 때까지 키 배열, 값 배열 전부를 돌아야 하고 둘의 검색 결과를 매칭하는 작업까지 해야한다. 그래서 배열의 사이즈가 커질수록 작업 비용이 늘어난다. 메모리 누수 Map은 이터러블 객체를 인자로 받는다. 그래서 보통 배열을 사용하는데, 배열의 특징이 다른 객체에 사용되지 않는(즉, 가비지 콜렉팅의 대상인) 오브젝트를 계속해서 유지한다는 점이다. 이 점으로 인해 불필요한 메모리 소비가 일어난다. WeakMap도 이터러블 객체를 인자로 받아서 배열을 사용하긴 하지만, GC(Garbage Collecting, 어떤 객체도 접근할 수 없는 객체)의 대상인 객체는 WeakMap내부에서도 자동으로 삭제하기 때문에 메모리 관리에 유리하다. WeakMap 인스턴스 만들기1234567891011let obj = &#123;&#125;;// 키는 객체, 값은 anyconst emptyWeakMap = new WeakMap(obj, &apos;오브젝트&apos;);or // 이터러블 오브젝트 안([])에 [key, value]로 작성const emptyWeakMap = new WeakMap([[obj, &apos;오브젝트&apos;]]);console.log(emptyWeakMap); // WeakMap &#123;&#125;, WeakMap은 콘솔로 내부를 들여다볼 수 없다. Map에 있는 .size도 없어서 브라우저 디버깅으로 내부를 본다. 불필요한 키 객체(Key Object) 삭제하기WeakMap의 프로퍼티 키로 있던 오브젝트가 GC(Garbage Collecting)의 대상이 되면, WeakMap에서도 해당 객체를 지운다. Map은 오브젝트가 삭제돼도 자신의 프로퍼티에 새긴 오브젝트를 자동으로 지우진 않는다. 12345678910111213141516171819const newWeakMap = new WeakMap();&lt;!-- 키가 될 객체 --&gt;let sportsObj = [1];&lt;!-- 값이 될 객체 --&gt;let oobj = &#123;subject : &quot;soccer&quot;&#125;;newWeakMap.set(sportsObj, oobj ); // 0: &#123;Object =&gt; &quot;soccer&quot;&#125;&lt;!-- 키 객체 지우기. 객체가 소거된다 --&gt;sportsObj = null;console.log(newWeakMap.has(sportsObj)); // false, 키가 없어졌다. 스택오버 플로우의 예를 살짝 바꿨는데, 함수 내에 쥐고 있던 변수를 Map은 계속 가지고 있었고 WeakMap은 가지고 있지 않았다. 123456789101112131415161718const map = new Map();const weakMap = new WeakMap();const func = () =&gt; &#123; let a = &#123; x : 12&#125;; let b = &#123; y : 12&#125;; map.set(a, 1); return weakMap.set(b, 2); // 디버거로 확인 key : &#123; y: 12 &#125;, value: 2&#125;const propWeakMap = func();console.log(map); // Map &#123; &#123; x: 12 &#125; =&gt; 1 &#125;console.log(propWeakMap); // key : &#123; y: 12 &#125;, value: 2console.log(map.size); // 1, 프로퍼티 a가 그대로 남아있다.console.log(propWeakMap.has(&#123;y: 12&#125;)); // false 변수 b가 지역변수라 함수 밖에서 b로 접근이 안 됐다. 그래서 디버깅으로 함수 내부의 WeakMap값을 알아내서, 밖에서 사용할 수 있게 리턴을 했다. 여기에 키를 조회할 수 있는 .has()를 써보니 value가 없는 것으로 나왔다. 스코프가 달라지면서 value값이 사라진 것으로 보인다. 프로퍼티의 키가 아니라 프로퍼티의 값이 사라지는 경우는 다르다. 값의 역할을 하던 객체를 건드리면 WeakMap에는 수정 전의 값이 남아있었다. 123456789101112131415const newWeakMap = new WeakMap();let sportsObj = [1];let oobj = &#123;subject : &quot;soccer&quot;&#125;;newWeakMap.set(sportsObj, oobj ); // 0: &#123;Object =&gt; &quot;soccer&quot;&#125;oobj = null;console.log(newWeakMap.get(sportsObj)); // &#123; subject: &apos;soccer&apos; &#125; WeakMap을 활용한 은닉화1234567891011121314151617181920212223242526272829&lt;!-- weakmap.js --&gt;const privates = new WeakMap();// public APIfunction Public()&#123; const data = &#123; // private data confidential : &apos;중요한 데이터&apos; &#125; // Public 인스턴스가 생성되면 매핑을 시작한다. privates.set(this, data);&#125;or// public APIclass Public &#123; constructor (data) &#123; privates.set(this, data); &#125;&#125;Public.prototype.method = function () &#123; const data = privates.get(this); console.log(data); // &#123; confidential : &apos;중요한 데이터&apos; &#125;&#125;module.exports = Public; WeakMap 인스턴스인 privates로 변수 data를 매핑했다. 이 변수의 값을 알고 싶다면 method()를 써서 privates.get API를 활용해야 한다. weakmap.js 파일에서 Public만을 모듈로 내보냈기 때문에 변수 privates을 초기화한 코드는 안전하게 유지할 수 있다.","categories":[],"tags":[{"name":"Weakmap, Symbol, es6, javascript","slug":"Weakmap-Symbol-es6-javascript","permalink":"https://wonn223.github.io/tags/Weakmap-Symbol-es6-javascript/"}]},{"title":"자바스크립트 - ES6프록시, proxy pattern","slug":"pattern","date":"2018-01-24T08:49:09.000Z","updated":"2018-01-24T08:49:09.000Z","comments":true,"path":"2018/01/24/pattern/","link":"","permalink":"https://wonn223.github.io/2018/01/24/pattern/","excerpt":"","text":"es6에서 proxy라는 새로운 객체를 내놨는데, ECMAScript에서 프록시 패턴을 내장해준 것이라고 한다. 프록시 패턴이 무엇인지, 그리고 es6에서 프록시를 어떻게 사용하는지 찾아보고 정리해봤다. 프록시 패턴언제 쓰는지? 외부에서 객체 접근을 통제하고 싶을 때(특정 객체의 일을 대신 해준다.) 사이즈가 큰 객체를 레이지 로딩하고 싶을 때 일단 차 목록이 담긴 객체와 프로토타입을 만들어봤다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const CarList = function() &#123; this._carList = &#123; 1 : &apos;Acar&apos;, 2 : &apos;Bcar&apos;, 3 : &apos;Ccar&apos;, &#125;&#125;;CarList.prototype = &#123; getCar: function (number) &#123; console.log(this); // &#123; _carList : &#123; ... &#125;&#125;를 가리키고 있다. return console.log(&apos;조회 결과&apos;, this._carList[number]); &#125;, search(number) &#123; if(this._carList[number]) &#123; return console.log(&apos;검색 결과&apos;, true); &#125; else &#123; return console.log(&apos;검색결과&apos;, false); &#125; &#125;, // 세터 함수 set addCar(newCar) &#123; // 복사본 할당 const carList = Object.assign(this._carList, newCar); console.log(carList); return this.carList; &#125;&#125;// 코드 확인let Owner1 = new CarList();let Owner2 = new CarList();console.log(Owner1.__proto__ === CarList.prototype); // trueOwner1.getCar(3); // CcarOwner1.search(3); // trueOwner1.addCar = &#123; 4: &apos;Dcar&apos;&#125; ; // &#123; &apos;4&apos;: &apos;Dcar&apos; &#125; 추가console.log(Owner1); // &#123; _carList: &#123; &apos;1&apos;: &apos;Acar&apos;, &apos;2&apos;: &apos;Bcar&apos;, &apos;3&apos;: &apos;Ccar&apos;, &apos;4&apos;: &apos;Dcar&apos; &#125; &#125;console.log(Owner2); // &#123; _carList: &#123; &apos;1&apos;: &apos;Acar&apos;, &apos;2&apos;: &apos;Bcar&apos;, &apos;3&apos;: &apos;Ccar&apos; &#125; &#125;console.log(new CarList()) // &#123; _carList: &#123; &apos;1&apos;: &apos;Acar&apos;, &apos;2&apos;: &apos;Bcar&apos;, &apos;3&apos;: &apos;Ccar&apos; &#125; &#125;, 원본 확인//``` setter와 Object.assign()을 활용해서 _carList 변수에 직접적인 접근을 제한하려 했다. 세터/게터로만 접근하는 방법의 단점을 찾아보다가, 클래스 컨스트럭터 내부에서 프로퍼티를 선언하고 게터/세터로 그 프로퍼티에 접근하는 방식도 찾을 수 있었다. 하지만 두 방식 모두 게터/세터를 특정 변수마다 하나씩 선언해야 하는 단점이 있다. 이를 고쳐준 게 es6의 Proxy였다. (Proxy에 정해진 틀에 바꾸고 싶은 타겟 객체, 타겟 객체에 어떤 방식을 가미할 지등을 넣어주면 된다.)모든 프록시 프로토타입에 원본 객체의 메소드를 적용시켜놔서, 원본을 활용하지 않고 프록시 인스턴스 만으로 원하는 동작을 처리할 수 있었다. 예제를 따라 쳐보면서 프록시가 앵귤러 서비스와 비슷하단 느낌이 들었다. const CarListProxy = function() { this.carList = new CarList();}; CarListProxy.prototype = { getCar(number) { return this.carList.getCar(number); }, search(number){ return this.carList.search(number); }, addCar(newCar){ return this.carList.addcar = newCar; } }123### 프록시를 이용한 레이지로딩만약 carList나 prototype이 가진 사이즈가 크다면, 실행에 부담이 갈 수 있다. 그래서 프록시를 활용하면 특정 기능이 실행됐을 떄(트리거), carList를 초기화할 수 있다고 한다. // 초기화 늦추기(레이지 로딩)const CarList = function() { this._carList = { 1 : ‘Acar’, 2 : ‘Bcar’, 3 : ‘Ccar’, }}; CarList.prototype = { getCar: function (number) { return console.log(‘조회 결과’, this._carList[number]); }, search(number) { if(this._carList[number]) { return console.log(‘검색 결과’, true); } else { return console.log(‘검색결과’, false); } }, set addCar(newCar) { const carList = Object.assign(this._carList, newCar); return this.carList; }} const CarListProxy = function() { this.carList = null; // 일단 CarList 생서자를 실행시키지 않는다.}; CarListProxy.prototype = { init() { this.carList = new CarList(); }, // 아래 메소드가 작동할 때 init이 호출되고, 차 목록 초기화가 일어난다. getCar(number) { this.init(); return this.carList.getCar(number); }, search(number){ this.init(); return this.carList.search(number); }, addCar(newCar){ this.init(); return this.carList.addcar = newCar; } } let instance_proxy = new CarListProxy(); console.log(instance_proxy.carList); // nullconsole.log(instance_proxy.getCar(3)); // 조회 결과 Ccarconsole.log(instance_proxy.carList); // { _carList: { ‘1’: ‘Acar’, ‘2’: ‘Bcar’, ‘3’: ‘Ccar’ } }```","categories":[],"tags":[{"name":"프록시 패턴, es6, 프록시, proxy","slug":"프록시-패턴-es6-프록시-proxy","permalink":"https://wonn223.github.io/tags/프록시-패턴-es6-프록시-proxy/"}]},{"title":"immutable한 객체 만들기 - Immutable.js의 Map","slug":"immutable","date":"2018-01-23T10:48:25.000Z","updated":"2018-01-24T09:26:46.000Z","comments":true,"path":"2018/01/23/immutable/","link":"","permalink":"https://wonn223.github.io/2018/01/23/immutable/","excerpt":"","text":"https://developers.redhat.com/blog/2017/01/17/data-encapsulation-vs-immutability-in-javascript/ immutable한 객체를 만드는 법을 소개한 글인데, 대략적으로 해석해봤다. ES6에서 나온 데이터구조, 클로저, 그리고 위에서 사용한 immutable.js 등 변하지 않는 개체를 만드는 방법이 많은 것 같다. 방법마다 어떤 장,단점이 있는지 잘 정리해봐야겠다. Object.freeze123456789101112131415class Product &#123; constructor(name) &#123; this.name = name; this.id = 20000; Object.freeze(this); &#125;&#125;const widget = new Product(&apos;widget&apos;)console.log(widget); // Product &#123; name: widget, id: 20000 &#125;widget.name = &apos;coffee&apos;;console.log(widget); // Product &#123; name: widget, id: 20000 &#125;, 얼려서 변환이 안 됨 만약 this.price = getPrice(); 처럼 값이 자주 달라지는 프로퍼티가 존재할 수 있다. 이 프로퍼티가 함수 같은 참조값을 가지고 있다면, 기존 클래스 인스턴스의 price프로퍼티에 많은 변동이 생길 수 있다. 그래서 Object.assign()으로 price를 immutable한 값으로 만든다. 123456789101112131415161718192021class Product &#123; constructor(name) &#123; this.name = name; this.id = 20000; this.price = getPrice(); Object.freeze(this); &#125; updatePrice() &#123; // new Product() 실행되면? 결과물(&#123; &#125;)은 freeze된 상태다. return Object.assign(new Product(), this, &#123; price : getPrice()&#125; ) &#125;&#125;const widget = new Product();widget.updatePrice();// Type Error. Cannot assign to read only property // new Product() 결과가 freeze의 영향으로 읽기 전용이 되기 때문에 에러가 발생한다. 다른 방법이 필요하다. 얼린 객체를 만드는 공장을 하나 짓는다.123456789101112131415161718192021222324252627282930&lt;!-- 1. Product와 똑같은 프로퍼티를 지닌 객체를 만들고 얼린다. --&gt;const productFactory = (name,price) =&gt; &#123; return Object.freeze(&#123;name, price&#125;); &#125;&lt;!-- 1-2. 얼린 객체를 변수에 할당한다. --&gt;const newWidget = productFactory(&apos;acme widget&apos;, 1.00);console.log(newWidget); // &#123; name: &apos;acme widget&apos;, price: 1 &#125;&lt;!-- 2. newWidget을 object.assign 소스 인자로 던져주고 빈 객체에 복사된 결과물을 다시 얼린다. --&gt;const updatePrice = product =&gt; &#123; return Object.freeze(Object.assign(&#123;&#125;, product, &#123; price : product.price * 1.04 &#125;) );&#125;const UpdateNewWidgt = updatePrice(newWidget);console.log(UpdateNewWidgt); // &#123; name: &apos;acme widget&apos;, price: 1.04 &#125; 디스트럭쳐링을 활용해서 서로 다른 객체의 값을 합치는 것처럼, 여기서도 빈 객체에 기존의 인스턴스와 price 객체를 object.assign으로 합하고 있다. 단 이 방법은 여러 중첩된 객체를 가지고 있는 프로퍼티가 있을 땐 비효율적이다. 프로퍼티 내부의 프로퍼티를 바꾸고 나서 중첩된 스코프마다 일일이 Object.freeze()를 해줘야하기 때문이다. Immutable.js 활용하기처음부터 프로퍼티를 초기화 할 때 Immutable한 객체를 할당하면 위와 같은 현상을 미리 예방할 수 있다. 이를 도와주는 패키지가 Immutable.js다. npm에서 immutable 패키지를 설치하고 새 파일을 연 다음, 얼린 객체를 생성할 모듈을 만든다. 아래에서는 Immutable의 데이터 구조 유형 중 하나인 Map을 사용했다.123456789&lt;!-- immutable.js --&gt;const Immutable = require(&apos;immutable&apos;);const factory = (name, price) =&gt; &#123; // immutable한 Map으로 데이터 구조가 바뀜 return Immutable.Map(&#123;name, price&#125;);&#125;module.exports = exports = &#123; factory &#125;; 1234567891011121314151617&lt;!-- product.js --&gt;const Product = require(&apos;./immutable.js&apos;);const widget = Product.factory(&apos;acme widget&apos;, 1.00);console.log(widget);// Map &#123; &quot;name&quot;: &quot;acme widget&quot;, &quot;price&quot;: 1 &#125;&lt;!-- widget에 Map.set()으로 정보 업데이트 --&gt;const updatedWidget = widget.set(&apos;price&apos;, 1.04);console.log(updatedWidget);// Map &#123; &quot;name&quot;: &quot;acme widget&quot;, &quot;price&quot;: 1.04 &#125;console.log(widget);// Map &#123; &quot;name&quot;: &quot;acme widget&quot;, &quot;price&quot;: 1 &#125; 초기값을 설정한 변수 widget에 set을 사용했지만 widget의 값은 달라지지 않았다. Map.set(‘key’)으로 반환 받은 객체는 widget의 복사 객체기 때문이다. Immutable.js에서 Map을 가진 객체는 자신의 값까지 포함해서 하나의 키가 될 수 있다.12345678910111213141516171819&lt;!-- immutable 모듈 로딩 --&gt;const Immutable = require(&apos;immutable&apos;);// &lt;!-- Map 초기화 후 할당 --&gt;const person = Immutable.Map(&#123; key1: &apos;hello&apos;, key2: &apos;world&apos;&#125;)let cloned_person = Immutable.Map();// &lt;!-- person 객체를 키로 사용하기 --&gt;cloned_person = cloned_person.set(person, &apos;객체 전체가 키가 됩니다.&apos;) console.log(cloned_person);// Map &#123; &#123;&quot;key1&quot;:&quot;hello&quot;,&quot;key2&quot;:&quot;world&quot;&#125;: &quot;객체 전체가 키가 됩니다.&quot; &#125;console.log(cloned_person.get(person)); // 객체가 키가 됩니다. List12345678// Immutable의 Array. 배열 관련 메소드를 내장하고 있다.const list = Immutable.List([ &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])list.count(); // 4list.push(&apos;e&apos;); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;, &apos;e&apos;]list.pop() // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;] OrderedMapOREDEDMAP : 순서가 있는 맵. set(적용)이 된 순서대로 인덱스가 적용된다. 배열 관련 메소드를 가지고 있고 first,last가 있는 게 특징 1234567891011const Immutable = require(&apos;immutable&apos;);let OrderdedMap = Immutable.OrderedMap(&#123; mary : 25, chan : 27&#125;);console.log(OrderdedMap.last()); // 27console.log(OrderdedMap.first()); // 25const aa = OrderdedMap.sortBy((value, key)=&gt; &#123; return -value;&#125;)console.log(aa); // OrderedMap &#123; &quot;chan&quot;: 27, &quot;mary&quot;: 25 &#125; ``` 출처 https://blog.jscrambler.com/immutable-data-immutable-js/ Immutable의 데이터 구조는 Map외에 List, Stack, Set, Record 등 다양하다. 아래의 사이트에서 각 데이터 구조를 예시와 함께 확인할 수 있다. https://velopert.com/3354 Map과 메소드를 활용한 immutable 객체 생성을 보여준다. immutable.js의 Map은 자바스크립트 객체보다 객체 안의 객체 프로퍼티에 보다 쉽게 접근할 수 있는 것을 확인할 수 있다.","categories":[],"tags":[{"name":"immutable, immutable.js, Object.freeze","slug":"immutable-immutable-js-Object-freeze","permalink":"https://wonn223.github.io/tags/immutable-immutable-js-Object-freeze/"}]},{"title":"자바스크립트 이해하기 - 프로퍼티와 Enumerable","slug":"enumerable","date":"2018-01-22T09:33:55.000Z","updated":"2018-01-23T06:56:34.000Z","comments":true,"path":"2018/01/22/enumerable/","link":"","permalink":"https://wonn223.github.io/2018/01/22/enumerable/","excerpt":"","text":"객체 안에 선언한 프로퍼티는 키와 값으로만 이루어진 개념이라 생각했었는데 어트리뷰트까지 가지고 있었고, 그 종류도 프로퍼티 성격에 따라 나뉜다는 걸 알았다. configurable/writable/enumerable 등등 여러 어트리뷰트 중에서 Enumerable 어트리뷰트를 좀더 찾아봤다. 프로퍼티 별 어트리뷰트 : 데이터 프로퍼티와 접근자 프로퍼티1) 데이터 프로퍼티 value와 writable 어트리뷰트를 가지고 있다. value는 프로퍼티가 가지고 있는 값을 말한다. writable은 재할당 가능 여부를 알려주는 어트리뷰트다. 2) 접근자 프로퍼티 게터와 세터가 여기에 해당한다. 3) 데이터 프로퍼티와 접근자 프로퍼티가 모두 가지는 것 enumerable/configurable 어트리뷰트가 있다. enumerable은 for 루프나 Object.keys()로 접근 시 프로퍼티의 노출가능성을 알려주는 어트리뷰트다. Enumerable기본적으로 프로퍼티의 enumerable flag는 true로 설정되어 있다고 한다.1234567891011121314151617const obj = &#123; purposeOfLife: 42&#125;&lt;!-- purposeOfLife 프로퍼티와 관련된 어트리뷰트를 보여준다. --&gt;console.log(Object.getOwnPropertyDescriptor(obj, &apos;purposeOfLife&apos;));&#123; value = 42, writable = true, enumerable = true, configurable = true&#125;&lt;!-- 어트리뷰트 중 enumerable만 확인하고 싶다면 --&gt;console.log(obj.propertyIsEnumerable(&apos;purposeOfLife&apos;)); // true 최초에 Enumerable 값이 false로 되어 있는 경우 : 내장된 객체의 프로퍼티는 Non-Eunmerable이다. 123객체 prototype의 프로퍼티 toString메소드 체크console.log(&#123;&#125;.propertyIsEnumerable(&apos;toString&apos;)); // false Object.defineProperty()메소드로 오브젝트 프로퍼티를 정의내리면, enumerable 기본값이 false가 되어있다. 123456789101112131415예제)age란 프로퍼티를 가진 man 객체에 fullname 프로퍼티를 추가시기키let man = &#123;age : 18&#125;;Object.defineProperty(man, &apos;fullname&apos;, &#123; value : &quot;John Resig&quot;&#125;)console.log(man.fullname); // John Resigconsole.log(Object.keys(man)); // [ &apos;age&apos; ]-&gt; non-enumerable인 프로퍼티 fullname은 나오지 않음. -&gt; 단, enumerable : true를 명시적으로 입력하면 기본값이 사라진다. Object.defineProperty()로 어트리뷰트 바꾸기 메소드의 세 번째 인자로 서술자 객체라는 것이 들어가는데, 이 객체 안에 프로퍼티 어트리뷰트가 담겨 있다.1234567891011121314let man = &#123;age : 18, fullname: &apos;unknown&apos;&#125;;// &lt;!-- 인자 1 : 프로퍼티가 있는 객체, 인자2 : 타겟 프로퍼티 인자3 : 서술자 객체 --&gt;man = Object.defineProperty(man, &apos;fullname&apos;, &#123; value : &quot;BrendanEich&quot;, configurable : false&#125;)&lt;!-- value 변경 확인 --&gt;console.log(man); // &#123; age: 18, fullname: &apos;BrendanEich&apos; &#125;&lt;!-- configurable 적용 확인 --&gt;console.log(delete man.fullname); // false Object.getOwnPropertyDescriptor()로 프로퍼티 어트리뷰트 조회하기1234let man_descriptor = Object.getOwnPropertyDescriptor(man, &apos;fullname&apos;);console.log(man_descriptor.value); // Brendan Eichconsole.log(man_descriptor.configurable); // false; Enumerable : true에 영향을 받는 메소드프로퍼티가 Enumerable flag의 값을 false로 가지고 있다면, JSON.stringify메소드로 검색되지 않는다. 123456789101112131415let obj = &#123; name: &apos;scoth.io&apos;, name_nonenum: &apos;scoth.co.kr&apos;&#125;Object.defineProperty(obj, &apos;name_nonenum&apos;, &#123; enumerable: false&#125;)console.log(obj.propertyIsEnumerable(&apos;name_nonenum&apos;)); // falselet jsonObj = JSON.parse(JSON.stringify(obj));console.log(jsonObj); // &#123; name: &apos;scoth.io&apos; &#125; Enumerable: false면 객체 프로퍼티를 모아서 보여주는 Object.keys()에서 검색되지 않는다.12345678910let man = &#123;age : 18, fullname: &apos;unknown&apos;&#125;;man = Object.defineProperty(man, &apos;fullname&apos;, &#123; value : &quot;Brendan Eich&quot;, enumerable : false, configurable : false&#125;)console.log(Object.keys(man)); // [ &apos;age&apos; ] non-eumerable인 프로퍼티까지 보려면 Object.getOwnPropertyNames(obj)를 사용한다. 1console.log(Object.getOwnPropertyNames(man)); // [ &apos;age&apos;, &apos;fullname&apos; ] for in 문에서 검색되지 않는다.123for ( let v in man ) &#123; console.log(v); // age&#125; 언제 Enumerable 어트리뷰트를 고려하나? private한 프로퍼티를 원할 때?위 예시에서 보듯 JSON.stringfy()나 for루프, 프로퍼티 접근 메소드에서 non-enumerable은 노출되지 않기 때문에, private한 프로퍼티를 만들고 싶을 때 enumerable 어트리뷰트를 사용하면 될 것이란 생각이 들었다. 하지만 Dr. Axel Rauschmayer는 완전한 private 프로퍼티가 안 된다고 말하고 있다. 읽기 전용이 되지만 getter로 enumerable한 프로퍼티에 접근할 수 있고, 여전히 프로퍼티 접근이 가능한 메소드가 있어서 복사를 할 때 non-enumerable프로퍼티는 복사가 안 되서 등 그래서 보다 더 안전한 은닉화를 원한다면 클로저나 WeakMap,’Symbol’과 같은 개념을 사용한다. WeakMap12345678910111213141516171819const privates = new WeakMap();class Product &#123; constructor(name) &#123; console.log(this); // Product &#123;&#125; this.name = name; privates.set(this, &#123; id: 234087 &#125;); &#125; related() &#123; return console.log(privates.get(this)); &#125;&#125;const tea = new Product(&apos;coffee&apos;);tea.related(); // &#123; id: 234087 &#125; 1234567891011121314const ID = Symbol(&apos;id&apos;);class Product &#123; constructor (name) &#123; this.name = name; this[&apos;id&apos;] = 234087; related () &#123; return console.log(this[&apos;id&apos;]); &#125; &#125; const tea = new Product(&apos;coffee&apos;) tea.related(); // 234087 Symbol은 Object.getOwnPropertyNames()에 드러나지 않지만 Reflect.ownKey()s나 Object.getOwnPropertySymbols()에서는 노출이 된다.프로퍼티 노출은 되지만 접근은 불가능. 12345678910111213141516171819202122232425262728293031323334namespace Validation &#123; export interface StringValidator &#123; isAcceptable(s: string): boolean; &#125;&#125;const lettersRegexp = /^[A-Za-z]+$/;const numberRegexp = /^[0-9]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return letterRegexp.test(s); &#125;&#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];let validator &#123; [s:string]= Validation.StringValidator &#125; = &#123;&#125;;validators[&quot;Zip code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();for (let s of strings) &#123; for (let name in validators) &#123; console.log(); &#125;&#125; 출처https://johnresig.com/blog/ecmascript-5-objects-and-properties/ ES5 새 기능 중 Object와 관련된 새 기능을 소개해준다. 프로퍼티와 서술자(Descriptors) 설명도 있음. http://2ality.com/2015/10/enumerability-es6.html enumerable에 전반적인 내용이 담겨있다. http://boycoding.tistory.com/38 [소년코딩] 서술사 객체 설명과 예시를 본 사이트.","categories":[],"tags":[{"name":"es5, enumerable, 자바스크립트, 프로퍼티","slug":"es5-enumerable-자바스크립트-프로퍼티","permalink":"https://wonn223.github.io/tags/es5-enumerable-자바스크립트-프로퍼티/"}]},{"title":"자바스크립트 - 객체 복사하기","slug":"copy","date":"2018-01-21T09:38:43.000Z","updated":"2018-01-25T12:46:56.000Z","comments":true,"path":"2018/01/21/copy/","link":"","permalink":"https://wonn223.github.io/2018/01/21/copy/","excerpt":"","text":"객체를 참조하는 경우가 많아지면 제어 흐름에 어려움을 겪는다는 이야길 많이 접하고 있다. 제어흐름을 신경써야할 만큼 큰 규모의 웹 앱을 만들어보지 않았지만, 객체의 참조를 피할 수 있는 법을 알아봤다. 새 객체 만들기 : Object.create(proto[, propertiesObj])인자 proto : 새롭게 만들어질 객체의 프로토타입이 될 객체 1234567891011121314const person = &#123; name: &apos;&apos;, type : &quot;인간&quot;, getName : function() &#123; return this.name; &#125;&#125;// 복사let man1 = Object.create(person);man1.name = &apos;man 1&apos;;console.log(man1.type);console.log(man1.getName()); Object.assign(target, …sources)sources : target의 일원이 될 여러 객체를 일컫는다. 객체 안에 enumerable한 속성이 있으면 그 속성을 target객체로 복사한다. 주의할 점은 소스 인자에 있는 객체의 프로퍼티가 객체를 참조하고 있으면, target객체로 참조의 복사가 일어난다. 123456789101112131415161718192021let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;let newObj = Object.assign(&#123;&#125;, obj);console.log(newObj); //obj와 똑같은 형태가 만들어짐.newObj.a = 10;console.log(newObj.a); // 10 console.log(obj.a); // 1&lt;!-- newObj만 달라짐. 프로퍼티 값이 immutable이므로 --&gt;&lt;!-- 하지만 --&gt;newObj.b.c = 30;console.log(obj.b.c); // 30 obj도 객체의 프로퍼티가 달라졌다. 기존의 obj.b가 가진 값이 원시값이 아니라 mutable한 객체였기 때문에, newObj.b와 obj.b가 같은 메모리 주소를 가리키고 있는 상태다. 즉, obj.b가 가리키고 있는 메모리 주소의 참조가 newobj.b로 옮겨진 것. 대안 JSON.parse(JSON.stringify(object))를 활용한다. 123456789101112let obj2 = &#123; a: 1, b: &#123; c: 2 &#125;&#125;let newObj2 = JSON.parse(JSON.stringify(obj2));newObj2.b.c = 20;console.log(obj2); // &#123; a: 1, b: &#123; c: 2 &#125; &#125;console.log(newObj2); // &#123; a: 1, b: &#123; c: 20 &#125; &#125; 단, JSON.parse는 메소드 복사가 안 된다.. 123456789101112131415161718//scoth.io 예제let obj3 = &#123; name: &apos;scoth.io&apos;, exec: function exec()&#123; return true; &#125;&#125;let method1 = Object.assign(&#123;&#125;, obj3);let method2 = JSON.parse(JSON.stringify(obj3));console.log(method1);// &#123; name: &apos;scoth.io&apos;, exec: [Function: exec] &#125;console.log(method2); // &#123; name: &apos;scoth.io&apos; &#125; 함수객체가 복사되지 않는 이유는 JSON에서 함수를 데이터로 보지 않기 때문이다. (함수 제외)오브젝트, 스트링, 넘버, 배열, 불리언을 제외한 유형은 인코딩 과정에서 무시된다고 한다. JSON메소드를 사용하지 않고 아래의 링크처럼 직접 깊은 복사를 구현한 함수를 쓰기도 한다. https://jsperf.com/deep-copy-vs-json-stringify-json-parse ES6 스프레드(…) 연산자 사용 123456789101112131415161718192021// 스프레드 연산자는 새 객체에 enumerable한 객체를 할당하는 데 사용한다.const original = &#123; a : &#123; b: 1&#125;&#125;;const falseCopy = &#123;...original&#125;;falseCopy.a.b = 10;console.log(original); // &#123; a: &#123; b: 10 &#125; &#125;console.log(falseCopy); // &#123; a: &#123; b: 10 &#125; &#125;const original = &#123; a: &#123; b: 1 &#125;, anotherRandomValue: 42 &#125;;// Always put the original with the spread operator firstconst falseCopy = &#123; ...original, a: &#123; b: 2 &#125; &#125;;console.log(falseCopy) // logs &#123; a: &#123; b: 2 &#125;, anotherRandomValue: 42 &#125;console.log(original) // logs &#123; a: &#123; b: 1 &#125;, anotherRandomValue: 42 &#125; 복사가 되지 않는 것들 : 프로토타입 체인에 있거나 non-enumerable한 객체12345678910111213141516171819202122232425262728293031let someObj = &#123; a: 2&#125;let obj = Object.create(someObj, &#123; b : &#123; value: 2, // enumerable : false이므로 복사되지 않는다. &#125;, c : &#123; value: 3, enumerable: true &#125;&#125;);// someObj는 obj의 프로토타입 객체가 되었으므로 복사되지 않음.console.log(obj.__proto__); // &#123; a : 2&#125;console.log(Object.getOwnPropertyDescriptor(obj, &apos;b&apos;));&#123; value: 2, writable: false, enumerable: false, configurable: false &#125;let objCopy = Object.assign(&#123;&#125;, obj)console.log(objCopy); // &#123; c : 3 &#125; 프로퍼티가 enumerable한 성격인지 확인하고 싶다면, Object에 내장된 getOwnPropertyDescriptor나 propertyIsEnumerable()란 메소드를 사용한다. 객체의 프로퍼티를 데이터라고 하고, 데이터에 접근하는 권한을 가진 것을 가리켜 접근자라고 한다.","categories":[],"tags":[{"name":"깊은 복사, 얇은 복사, deep copy, 참조, 참조 복사","slug":"깊은-복사-얇은-복사-deep-copy-참조-참조-복사","permalink":"https://wonn223.github.io/tags/깊은-복사-얇은-복사-deep-copy-참조-참조-복사/"}]},{"title":"Javascript 이해하기 - 일을 분담시키는 비동기 로직과 스레드","slug":"async","date":"2018-01-19T10:52:47.000Z","updated":"2018-01-22T09:40:12.000Z","comments":true,"path":"2018/01/19/async/","link":"","permalink":"https://wonn223.github.io/2018/01/19/async/","excerpt":"","text":"브라우저는 기본적으로 메인 스레드라는 스레드 하나만 사용한다. 처리할 게 많아도 스레드는 한 번에 하나씩만 처리할 수 있다. 그동안 다른 작업은 큐에 있으면서 스레드의 처리를 기다리는데, 이 때 스레드가 작동을 멈춰야 하는 경우가 있다. 처리해야 하는 일이 동기적인 성격을 가진 경우인데(동기적으로 서버 데이터 불러오기), 이 때 스레드는 처리해야할 값이 올 때까지 가만히 기다리고 있어야 한다. 자연스레 큐에 있는 일의 대기시간도 늘어가기 때문에 비동기 기능를 적절히 사용해서 스레드의 작업 효율을 높여야 한다. 방법 : 비동기 API를 활용한다브라우저가 제공하는 기본 비동기 API setTimeOut: 특정 시간 이후의 프레임에 코드를 적재함 setInterval: 특정 간격의 프레임마다 코드를 적재함 requestAnimationFrame : 프레임 간의 시간 차를 확인해보고 코드를 넘겨야할 것 같다면, 다음 렌더링 타임으로 코드를 이동시킨다. DOM 이벤트 리스너 : dom에 이벤트를 달아놓고 이벤트가 생길 때 마다 코드를 적재함. XHR(AJAX) : HTML5 Web Worker, HTML GeoLocation, IndexedDB 등이 있다. DOM이벤트를 활용해서 비동기로 처리되는 일이 끝나면, DOM 이벤트 리스너를 활용해 완료한 일을 만질 수 있도록 제어권을 준다. 비동기가 가진 단점 : 서브루틴의 존재와 오류 처리.처리된 값을 받고 수정을 하는 서브루틴이 여러 개가 있으면, 스택 메모리도 쌓이고 가독성도 떨어진다. 또 서브루틴의 서브루틴을 실행시키는 도중에 오류가 생길 땐, 어디서 오류가 시작되었는지 파악하기 어렵다. 그래서 아래와 같이 에러 처리를 함수를 넣는다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- 기본적인 오류 처리 방법 : 에러를 잡는 콜백 함수를 하나 더 만든다. --&gt;let obj = getData( (res) =&gt; &#123; console.log(res);&#125;, (err) =&gt; &#123; thorw Error(&apos;err&apos;); &#125;)&lt;!-- 하지만 getData 안에 또 세부 정보를 얻는 getLocation()이 있다면? --&gt;let obj = getData( (res) =&gt; &#123; console.log(res); // getData성공 &#125; getLocation(location) &#123; console.log(location); // getLocation 성공 &#125; , fucntion(err) &#123; console.log(err); // getLocation실패 &#125;, fucntion(err) &#123; console.log(err); // getData실패 &#125; );// 복잡해진다. 콜백 헬&lt;!-- 프로미즈 사용 --&gt;let Promise = new Promise(resolve, reject) &#123; resolve(&apos;성공할 때 나올 메시지&apos;); reject(&apos;실패할 때 나올 메시지&apos;);&#125;Promise.then( (res) = &gt; &#123; console.log(res) // &apos;성공할 때 나올 메시지&apos;;&#125;).then(&apos;2번 연속 성공&apos;).cathch( (err) =&gt; &#123; console.log(&apos;3연속 실패&apos;);&#125;) // 콜백의 콜백을 보다 깔끔하게 표현한다.// catch문이 .then문으로 처리하는 도중에 생길 수 있는 오류를 잡아준다.&lt;!-- 하지만 스레드가 코드를 한 번 지나가면 끝이다. 코드에 쓴 만큼만 연속적으로 값을 가지고 처리한다. --&gt;&lt;!-- 코드가 한번 돌아도 데이터가 계속해서 유지되는 옵저버블(추가) --&gt;``` ### 웹워커로 스레드를 더 활용한다.자바스크립트는 처음에 만들어 질 때 브라우저에서 사용자 경험을 늘리는 데 목적이 있어서 브라우저 ui를 처리하는 스레드를 하나 밖에 가질 수 없었다. HTML5가 나오면서 웹워커를 활용해 UI스레드 외에 추가적인(백그라운드) 스레드를 사용할 수 있게 됐다. 웹 워커 공간에서 DOM을 비롯해 접근할 수 없는 객체가 여러 개 있지만, 복잡한 연산을 처리해서 메인 스레드로 넘겨주면 메인 스레드가 안정적인 처리를 할 수 있다.![웹워커 단점](./비동기로직/webworker단점.png)&lt;!-- ### 비동기 결과를 받는 방법1. 이벤트 형식 &lt;!-- 다음 작업을 진행한다. --&gt; &lt;!-- processData(); --&gt; &lt;!-- 실패했을 땐 오류 보여주기 --&gt; &lt;!-- console.log(httpObejct.err); --&gt;","categories":[],"tags":[{"name":"비동기, 웹 워커, AJAX, IndexedDB, 스레드, HTML5","slug":"비동기-웹-워커-AJAX-IndexedDB-스레드-HTML5","permalink":"https://wonn223.github.io/tags/비동기-웹-워커-AJAX-IndexedDB-스레드-HTML5/"}]},{"title":"앵귤러 이해하기(2) - NgZone 적용해보기","slug":"changedetection2","date":"2018-01-17T14:57:20.000Z","updated":"2018-01-17T16:14:51.000Z","comments":true,"path":"2018/01/17/changedetection2/","link":"","permalink":"https://wonn223.github.io/2018/01/17/changedetection2/","excerpt":"","text":"불필요한 변화감지를 막고자 NgZone을 사용하는데 실제로 변화감지를 일으키는 부분에 적용해봤다. 컴포넌트 트리 안에 있는 모든 컴포넌트는 트리거에 따른 변화를 감지한다. 오늘 변화 감지를 확인한 곳은 헤더 컴포넌트의 검색창이었다. 입력칸에 검색어를 입력하면 HTTP API로 DB 데이터에 있는 검색결과를 받아 오는데 이 과정에서 컴포넌트의 변화 감지가 발생한다. 검색창의 값(검색어)이 옵저버블 이란 인터페이스를 활용하고 있다. 옵저버블 타입을 가지면 서버에 있는 데이터를 계속해서 요청하고 받을 수 있다. 검색창에 글자를 입력할 때마다 서버로 Http Get이 이뤄지는데, 이 때 특정 시간까지 글자를 모아 서버에 검색어를 전달한다. 검색어를 전달하면 서버에서 검색결과를 주는데 이 과정에서 변화감지가 많이 일어나고 있었다. NgZone.runOutsideAngular()변화감지를 줄이려면 검색결과가 나오기 전까지 검색 과정의 작업을 앵귤러가 인식하지 못해야한다. 앵귤러 바깥 공간에서 검색어를 서버에 전달하고, 검색결과를 다시 앵귤러 공간으로 가지고 오는 방법이 runOutsideAngular다. 이 메소드를 검색결과를 가져오는 메소드에 적용시켜봤다. 앵귤러 바깥에서 처리된 값을 다시 앵귤러 영역(zone)에 적용시키려고 subscribe구독 시 run()메소드를 사용했다. 이 안에서 검색결과 참조값을 프로퍼티에 할당했다. 변화 감지를 줄이려고 객체를 참조하지 않고 변하지 않는 값(immutable)을 사용하기도 한다. immutable한 값을 사용하면 참조로 인한 예기치 않은 변동성을 예방할 수 있고, 값을 새로 복사할 때만 변화감지가 발생하기 때문이다. 이렇게 넣어본 다음 개발자 도구를 활용해 차이점이 있는지 확인해봤다. 확인 결과, 검색어를 입력을 마친 순간까지는 차이가 없었고, 검색 결과를 받아오는 부분에서 미세한 차이가 발생했다. 작업 시간만을 보면 스크립트 부분에서 6ms(0.006)의 차이가 생겼다. 반복해서 렌더링을 체크해봤을 때도 6ms와 비슷한 값이 나왔다. 느낀 점생각보다 미세하게 차이가 나서 변화감지의 차이를 좀더 드러낼 수 있는 방법을 찾아봐야겠다. 그리고 컴포넌트를 기능 별로 좀더 세세하게 분리시켜야겠단 생각이 들었다. 헤더의 검색어 입력 이벤트를 감지해야 하는 컴포넌트가 사실 거의 없다. 검색 컴포넌트를 따로 만들어서 헤더 컴포넌트에게만 @Input을 주고,헤더 컴포넌트만 검색 컴포넌트의 변화를 감지하는 방법을 알아봐야겠다. 브라우저의 fps가 너무 높게 나왔다. 적정 프레임이 60프레임으로 알고 있는데, 600(…뭐지)이 넘는 fps가 나왔다. 개발자 도구 퍼포먼스 탭에서 결과를 보니 도큐먼트 전체에 브라우저의 레이어 작업이 적용되고 있었다. 레이어 작업을 최소화하는 방법을 알아봐야겠다.","categories":[],"tags":[{"name":"change detection, 앵귤러2, 변화 감지, ngzone","slug":"change-detection-앵귤러2-변화-감지-ngzone","permalink":"https://wonn223.github.io/tags/change-detection-앵귤러2-변화-감지-ngzone/"}]},{"title":"앵귤러 이해하기 (1) 변화 감지 - 코딩하는(?) 타이밍 잡기","slug":"changedetection","date":"2018-01-14T16:20:49.000Z","updated":"2018-01-17T15:10:34.000Z","comments":true,"path":"2018/01/15/changedetection/","link":"","permalink":"https://wonn223.github.io/2018/01/15/changedetection/","excerpt":"","text":"앵귤러로 작업을 하다 보면 클릭/키보드 같은 입력 이벤트가 발생할 때 템플릿 스타일이나 프로퍼티 값을 바꿀 때가 많다. 변화가 일어나는 타이밍이 있어야 작업을 할 수 있다는 생각이 들 정도인데, 입력 이벤트 외에 무엇이 또 변화를 일으킬까 궁금해졌다. 이 부분을 알면 코드 짜기가 수월해질 것 같았다. 변화를 일으키는 트리거(Trigger) 3가지pascal precht가 말한(변화 감지 발표를 많이 하신 분이다) 변화 트리거는 3가지다. 트리거가 만드는 변화에 맞춰 뷰나 컴포넌트의 데이터를 어떻게 처리할 지 구상하면 될 것 같다. Events(이벤트) - click, submit… XHR(서버와의 통신) - Fetching data from a remote server(HTTP.get()…) Timers(타이머) - setTimeout(), setInterval() 그 외 앵귤러에 생명 주기와 관련된 메소드가 있는데, 이 메소드의 함수 바디 안에서 모델의 변경 사항을 뷰에 반영시키는 일을 할 수 있다. 참고) 이웅재 개발자님 강의 중 https://www.inflearn.com/course-status-2/ 앵귤러의 변화 감지 방식 : ‘위에서 아래로’ 모두가 아는 변화 빨간색으로 칠해진 컴포넌트는 특정 컴포넌트에서 변화가 생겼다는 사실을 알고 있다. CD는 변화감지기의 준말. 앞서 말한 트리거로 인해 컴포넌트 변화가 일어난다. 그러면 변화가 일어났다는 사실을 컴포넌트 트리를 형성하고 있는 모든 컴포넌트가 알게 된다. 이 때 가장 먼저 소식을 접하는 컴포넌트는 최상위 루트 컴포넌트다. 루트 컴포넌트가 변화를 인식하면, 루트 컴포넌트는 자기 아래에 있는 모든 컴포넌트에게 소식을 전파한다. 다른 컴포넌트의 소식을 다 알고 싶은 게 아니라면? 감지기를 끈다 회색이 칠해진 컴포넌트는 (자기 내부의 변화를 빼곤) 다른 컴포넌트의 변화 소식을 받지 않는다. 이처럼 기본적으로 컴포넌트 전체가 변화를 감지한다. 하지만 외부 컴포넌트의 변화 하나하나를 감지하길 원치 않는 컴포넌트는 변화 감지기란 것을 꺼서 소식을 받지 않는다. 변화감지기는 런타임에 생성되는데 이걸로 템플릿에 바인딩 된 프로퍼티가 달라졌는지 감지한다. 변화 감지기를 끄고 싶으면 NgZone의 메소드 OnPush()를 사용하면 된다. 이 메소드를 사용하면 외부의 변화를 감지하지 못하고, 자신의 컴포넌트 내부에 있는 프로퍼티는 값이 바뀌지 않는 immutable이라고 선언하는 것과 같다. 12345678import &#123; Component, Oninit, ChangeDetectionStrategy &#125; from &apos;@angular/core&apos;;@Component(&#123; ... changeDetection : ChangeDetectionStrategy.OnPush&#125;)export class SomeComponent &#123; &#125; 변화감지기의 구체적인 모습은?런타임에 컴포넌트의 타입스크립트와 html를 합친 componentName.ngFactory.js 클래스가 만들어진다. 이 클래스의 메소드인 detectChangeInternal를 활용해 각 컴포넌트는 변화 감지를 수행한다고 하는데..ChangeDetectorRef 디펜던시를 컨스트럭터에 주입하면 각 컴포넌트의 변화감지기를 참조할 수 있다. 12(생략)constructor (private cd : ChangeDetectorRef) &#123;...&#125; 변화 감지기를 선택적으로 껐다 켤 수도 있다. Input엘리먼트를 가지고 있는 컴포넌트는 외부 변화 감지를 하진 않아도 Input에서 나오는 value값을 다른 컴포넌트에 전달할 필요가 있다. Input value를 받는 컴포넌트의 경우도 마찬가지. 이런 경우에는 input value값이 달라지는 경우에만 변화감지기를 잠깐 열어둘 수도 있다. HTTP API로 옵저버블 타입의 Input value를 많이 주고 받는데 이 방법을 활용해 볼 필요가 있다고 생각했다. 1234567891011121314@Component()class CartBadgeCmp &#123; @Input() addItemStream : Observable&lt;any&gt; counter = 0; constructor(privated cd: ChangeDetectorRef)&#123;&#125; ngOnInit() &#123; this.addItemStream.subscribe(&#123; this.counter++; // 상태 변화가 발생 this.cd.markForCheck(); // 변화가 발생한 경우에만 자신의 위치에서 루트 컴포넌트까지 감지기를 켜둔다. &#125;) &#125;&#125; 이처럼 변화감지를 조절할 수 있는 방법은 다양하다. 적절한 변화감지 통제가 일어나면 매 프레임마다 처리할 코드가 많은 브라우저의 입장에선 렌더링 시간이 줄어들기 때문에 보다 부드러운 웹 화면을 만들 수 있다.(추후 브라우저 렌더링 포스팅) NgZone : 언제 끝날 지 모르는 비동기를 추적한다동기 함수와 다르게 비동기 함수는 기본적으로 언제 작업이 끝날 지 알기 어렵다. 변화가 일어난 순간을 정확히 감지하고 거기에 대응해야 하는 앵귤러의 입장에선 이를 다루기가 쉽지 않다. 그래서 비동기 함수의 시작과 끝을 정확히 파악해주는 것이 zone.js다. zone.js가 있어서 비동기 함수를 코딩할 때마다, 앵귤러에게 일일이 함수의 변화 순간을 알려 주지 않아도 된다. 직접 변화 감지를 통제 하고 싶다면, NgZone이라는 모듈을 활용해서 관련 메소드를 쓰면 된다. 참고) https://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/16 pascal precht의 발표 슬라이드. https://youtu.be/X0DLP_rktsc 1번 ppt를 가지고 발표하는 pascal precht. https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html 또 pascal precht의(…) 사이트. 변화 감지와 관련된 앵귤러 객체/메소드는 다음 포스팅에 올릴 예정","categories":[],"tags":[{"name":"앵귤러2+, change detection","slug":"앵귤러2-change-detection","permalink":"https://wonn223.github.io/tags/앵귤러2-change-detection/"}]},{"title":"CSS 이해하기 (1) position, z-index가 만든 쌓임 순서/ 쌓임 맥락","slug":"zindex","date":"2018-01-14T09:38:02.000Z","updated":"2018-01-22T09:37:33.000Z","comments":true,"path":"2018/01/14/zindex/","link":"","permalink":"https://wonn223.github.io/2018/01/14/zindex/","excerpt":"","text":"css 작업을 하다 보면 특정 요소를 다른 요소보다 앞에 두고 싶을 때가 있다. 그럴 땐 먼저 position : relative | absolute로 요소를 움직여본다. 작동이 안 되는 것 같으면 z-index를 활용했는데, 문제는 z-index마저 먹히지 않는 상황이 있다는 것(…). 그 이유를 찾아 보다가 쌓임 맥락(stacking context)이란 것을 알게 되었다. 쌓임맥락HTML문서가 DOM에서 렌더링 트리로 변할 때까지 트리의 렌더 오브젝트(DOM에선 노드)는 문서에 적힌 위계를 그대로 가지고 여러 개의 층(stack)을 이룬다. 스택에서 볼 수 있는 층 간의 위계를 쌓임 순서/위계(stacking order)라고 하며 각 층에서 오브젝트들이 저마다 형성한 위계를 쌓임 맥락(stacking context)이라 한다. 층이 쌓이는 순서는 기본적으로 HTML문서에 선언된 위치에 따라 결정되지만, 레이어에 변화를 일으키는 css프로퍼티(position, z-index)에 따라 그 순서가 달라진다. 이는 브라우저의 렌더링 작업에도 영향을 미친다. (브라우저 렌더링 작업에 관한 글은 따로 정리.) philpwalton의 글 중.. 어떤 엘리먼트의 쌓임 맥락(stacking context)이 쌓임 순서(stacking order) 상 가장 낮은 곳에 있는 경우엔 z-index의 값이 1억이라도, 쌓임 순서가 높은 엘리먼트보다 화면 앞에 위치할 수 없다. 쌓임 맥락을 만드는 요소들 문서의 뿌리 요소 엘리먼트 html // 예제 position 속성이 있고, z-index를 auto가 아닌 정수값으로 지정한 엘리먼트 // 예제 opacity를 1보다 낮게 설정한 엘리먼트 z-index를 정수값 지정했고 flex속성을 가진 엘리먼트 z-index를 정수값 || auto이고, position:fixed를 가진 엘리먼트 예제우선 z-index는 요소에 position 프로퍼티가 있을 때만 유효하다. position 속성이 없으면 z-index를 높여도 기존의 화면이 달라지지 않는다. 123456789101112131415161718192021222324#box_1 &#123; width: 200px; height: 200px; position: relative; z-index: 99; background: goldenrod;&#125;#box_2 &#123; width: 200px; height: 200px; position: relative; z-index: 500; margin-top: -72px; background: darkgreen;&#125;#box_3 &#123; width: 200px; height: 200px; position: relative; z-index: 1; background: darkcyan;&#125; 왼쪽이 세 개의 id에 position과 z-index 모두 적용했을 때 모습이다. 초록색 박스(div_2)가 금색 박스보다 z-index가 높고 margin-top속성을 가지고 있어서 금색 박스(div_1)를 덮었다. 오른쪽의 경우는 초록색 박스의 position 속성을 껐을 때다. z-index 속성이 무효화되고, 초록색 박스의 margin-top 값만큼 청록색 박스가 끌려 올라간 것을 알 수 있다. position 속성이 없어진 초록색 박스는 1,3번 박스와 다른 스택 맥락을 갖게 되었기 때문에 자신의 z-index는 자신이 위치한 새로운 쌓임 맥락에서만 유효하다. 같은 쌓임 맥락에 있는 요소들 끼리의 쌓임 순서가 결정되는 법Smashing magazine에서 알려 준 기본 stack 형성 순위는 다음과 같다.5번으로 갈수록 화면 앞으로 나온다. 배경과 보더를 형성하는 엘리먼트 음수 값을 가진 css 프로퍼티가 있는 엘리먼트( margin : - 10px ) float이 아니며 display : block인 엘리먼트 float인 엘리먼트 인라인 속성 엘리먼트(6. 포지션 | z-index 속성이 있는 엘리먼트) 부모의 쌓임 맥락과 자식의 쌓임 맥락은 또 다르다.부모와 자식은 별개의 맥락을 형성하고, 자식은 부모의 쌓임 맥락을 따르게 된다. 12345678910// html&lt;div id=&quot;box1&quot;&gt; &lt;span class=&quot;red&quot;&gt;Red&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt; &lt;span class=&quot;green&quot;&gt;Green&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span class=&quot;blue&quot;&gt;Blue&lt;/span&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// css.red, .green, .blue &#123; position: absolute; width: 100px; color: white; line-height: 100px; text-align: center;&#125;.red &#123; z-index: 999; top: 20px; left: 20px; background: red;&#125;.green &#123; z-index : 1000; // green이 red보다 z-index가 높다. // span 요소가 형성한 쌓임 맥락에선 green이 화면 제일 앞쪽에 위치한다. 하지만.. top: 60px; left: 60px; background: green;&#125;.blue &#123; top: 100px; left: 100px; background: blue;&#125;#box1 &#123; position : relative; z-index : 1000; // red 부모 요소의 z-index가 green 부모 요소의 것보다 값이 크다. // 그래서 red가 화면 제일 앞쪽에 위치한다.&#125;#box2 &#123; position: relative; z-index : 999;&#125; Codepen으로 확인하기 display:float인 경우 포지션이 지정된 엘리먼트와 그렇지 않은 엘리먼트 사이에 위치한다. 개념을 접하고 나서 [philpwalton의 글 중..] …If you’re setting a z-index of a billion on an element and it’s not moving forward in the stacking order, take a look up its ancestor tree and see if any of its parents form stacking contexts 만약 어떤 요소에 z-index를 줬는데 변화가 일어나지 않았다면 position 프로퍼티가 선언되었는지를 확인하거나, 부모 요소에 쌓임 맥락이 형성되어 있는지를 확인하면 원인을 파악할 수 있겠다는 생각이 들었다. 1) https://coding.smashingmagazine.com/2009/09/the-z-index-css-property-a-comprehensive-look/ &gt; smashingmagazine에서 제공하는 쌓임맥락 설명. 코드 예제와 z-index 적용된 사이트를 소개하고 있다. 2) https://mytory.net/archives/10997 &gt; 쌓임 맥락에 관한 기본적인 내용을 번역해 준 사이트 3) https://developer.mozilla.org/ko/docs/Web/CSS/Understanding_z-index/The_stacking_context &gt; MDN에서 제공하는 쌓임 맥락 이야기 4) https://gitlab.com/SeunghoLee/my-markup-project/issues/2 &gt; 정리를 깔끔하게 해주신 개발자님 깃북","categories":[],"tags":[{"name":"z-index, css, 쌓임맥락, stacking context, position","slug":"z-index-css-쌓임맥락-stacking-context-position","permalink":"https://wonn223.github.io/tags/z-index-css-쌓임맥락-stacking-context-position/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-13T09:59:07.000Z","updated":"2018-01-13T09:59:07.000Z","comments":true,"path":"2018/01/13/hello-world/","link":"","permalink":"https://wonn223.github.io/2018/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
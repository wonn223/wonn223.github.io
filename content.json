{"meta":{"title":"seokwon","subtitle":"Seokwon}.github.io","description":"seokwon's blog","author":"seokwon","url":"https://wonn223.github.io"},"pages":[],"posts":[{"title":"앵귤러 이해하기(2) - NgZone 적용해보기","slug":"changedetection2","date":"2018-01-17T14:57:20.000Z","updated":"2018-01-17T16:10:20.000Z","comments":true,"path":"2018/01/17/changedetection2/","link":"","permalink":"https://wonn223.github.io/2018/01/17/changedetection2/","excerpt":"","text":"불필요한 변화감지를 막고자 NgZone을 사용하는데 실제로 변화감지를 일으키는 부분에 적용해봤다. 컴포넌트 트리 안에 있는 모든 컴포넌트는 트리거에 따른 변화를 감지한다. 오늘 변화 감지를 확인한 곳은 헤더 컴포넌트의 검색창이었다. 입력칸에 검색어를 입력하면 HTTP API로 DB 데이터에 있는 검색결과를 받아 오는데 이 과정에서 컴포넌트의 변화 감지가 발생한다. 검색창의 값(검색어)이 옵저버블 이란 인터페이스를 활용하고 있다. 옵저버블 타입을 가지면 서버에 있는 데이터를 계속해서 요청하고 받을 수 있다. 검색창에 글자를 입력할 때마다 서버로 Http Get이 이뤄지는데, 이 때 특정 시간까지 글자를 모아 서버에 검색어를 전달한다. 검색어를 전달하면 서버에서 검색결과를 주는데 이 과정에서 변화감지가 많이 일어나고 있었다. NgZone.runOutsideAngular()변화감지를 줄이려면 검색결과가 나오기 전까지 검색 과정의 작업을 앵귤러가 인식하지 못해야한다. 앵귤러 바깥 공간에서 검색어를 서버에 전달하고, 검색결과를 다시 앵귤러 공간으로 가지고 오는 방법이 runOutsideAngular다. 이 메소드를 검색결과를 가져오는 메소드에 적용시켜봤다. 앵귤러 바깥에서 처리된 값을 다시 앵귤러 영역(zone)에 적용시키려고 subscribe구독 시 run()메소드를 사용했다. 이 안에서 검색결과 참조값을 프로퍼티에 할당했다. 변화 감지를 줄이려고 객체를 참조하지 않고 변하지 않는 값(immutable)을 사용하기도 한다. immutable한 값을 사용하면 참조로 인한 예기치 않은 변동성을 예방할 수 있고, 값을 새로 복사할 때만 변화감지가 발생하기 때문이다. 이렇게 넣어본 다음 개발자 도구를 활용해 차이점이 있는지 확인해봤다. 확인 결과, 검색어를 입력을 마친 순간까지는 차이가 없었고, 검색 결과를 받아오는 부분에서 미세한 차이가 발생했다. 원 안에 있는 시간은 성능 차이로 인한 결과라기보다 트랙패드로 렌더링 결과 범위를 다르게 잡아서 생긴 결과라 주의 깊게 보지 않아도 될 것 같았다. 이 부분을 제외하고 작업 시간만을 보면 스크립트 부분에서 6ms(0.006)의 차이가 생겼다. 반복해서 렌덜이 체크해봤을 때도 6ms와 비슷한 값이 나왔다. 느낀 점생각보다 미세하게 차이가 나서 변화감지의 차이를 좀더 드러낼 수 있는 방법을 찾아봐야겠다. 그리고 컴포넌트를 기능 별로 좀더 세세하게 분리시켜야겠단 생각이 들었다. 헤더의 검색어 입력 이벤트를 감지해야 하는 컴포넌트가 사실 거의 없다. 검색 컴포넌트를 따로 만들어서 헤더 컴포넌트에게만 @Input을 주고,헤더 컴포넌트만 검색 컴포넌트의 변화를 감지하는 방법을 알아봐야겠다. 브라우저의 fps가 너무 높게 나왔다. 적정 프레임이 60프레임으로 알고 있는데, 600(…뭐지)이 넘는 fps가 나왔다. 개발자 도구 퍼포먼스 탭에서 결과를 보니 도큐먼트 전체에 브라우저의 레이어 작업이 적용되고 있었다. 레이어 작업을 최소화하는 방법을 알아봐야겠다.","categories":[],"tags":[{"name":"change detection, 앵귤러2, 변화 감지, ngzone","slug":"change-detection-앵귤러2-변화-감지-ngzone","permalink":"https://wonn223.github.io/tags/change-detection-앵귤러2-변화-감지-ngzone/"}]},{"title":"앵귤러 이해하기 (1) 변화 감지 - 코딩하는(?) 타이밍 잡기","slug":"changedetection","date":"2018-01-14T16:20:49.000Z","updated":"2018-01-17T15:10:34.000Z","comments":true,"path":"2018/01/15/changedetection/","link":"","permalink":"https://wonn223.github.io/2018/01/15/changedetection/","excerpt":"","text":"앵귤러로 작업을 하다 보면 클릭/키보드 같은 입력 이벤트가 발생할 때 템플릿 스타일이나 프로퍼티 값을 바꿀 때가 많다. 변화가 일어나는 타이밍이 있어야 작업을 할 수 있다는 생각이 들 정도인데, 입력 이벤트 외에 무엇이 또 변화를 일으킬까 궁금해졌다. 이 부분을 알면 코드 짜기가 수월해질 것 같았다. 변화를 일으키는 트리거(Trigger) 3가지pascal precht가 말한(변화 감지 발표를 많이 하신 분이다) 변화 트리거는 3가지다. 트리거가 만드는 변화에 맞춰 뷰나 컴포넌트의 데이터를 어떻게 처리할 지 구상하면 될 것 같다. Events(이벤트) - click, submit… XHR(서버와의 통신) - Fetching data from a remote server(HTTP.get()…) Timers(타이머) - setTimeout(), setInterval() 그 외 앵귤러에 생명 주기와 관련된 메소드가 있는데, 이 메소드의 함수 바디 안에서 모델의 변경 사항을 뷰에 반영시키는 일을 할 수 있다. 참고) 이웅재 개발자님 강의 중 https://www.inflearn.com/course-status-2/ 앵귤러의 변화 감지 방식 : ‘위에서 아래로’ 모두가 아는 변화 빨간색으로 칠해진 컴포넌트는 특정 컴포넌트에서 변화가 생겼다는 사실을 알고 있다. CD는 변화감지기의 준말. 앞서 말한 트리거로 인해 컴포넌트 변화가 일어난다. 그러면 변화가 일어났다는 사실을 컴포넌트 트리를 형성하고 있는 모든 컴포넌트가 알게 된다. 이 때 가장 먼저 소식을 접하는 컴포넌트는 최상위 루트 컴포넌트다. 루트 컴포넌트가 변화를 인식하면, 루트 컴포넌트는 자기 아래에 있는 모든 컴포넌트에게 소식을 전파한다. 다른 컴포넌트의 소식을 다 알고 싶은 게 아니라면? 감지기를 끈다 회색이 칠해진 컴포넌트는 (자기 내부의 변화를 빼곤) 다른 컴포넌트의 변화 소식을 받지 않는다. 이처럼 기본적으로 컴포넌트 전체가 변화를 감지한다. 하지만 외부 컴포넌트의 변화 하나하나를 감지하길 원치 않는 컴포넌트는 변화 감지기란 것을 꺼서 소식을 받지 않는다. 변화감지기는 런타임에 생성되는데 이걸로 템플릿에 바인딩 된 프로퍼티가 달라졌는지 감지한다. 변화 감지기를 끄고 싶으면 NgZone의 메소드 OnPush()를 사용하면 된다. 이 메소드를 사용하면 외부의 변화를 감지하지 못하고, 자신의 컴포넌트 내부에 있는 프로퍼티는 값이 바뀌지 않는 immutable이라고 선언하는 것과 같다. 12345678import &#123; Component, Oninit, ChangeDetectionStrategy &#125; from &apos;@angular/core&apos;;@Component(&#123; ... changeDetection : ChangeDetectionStrategy.OnPush&#125;)export class SomeComponent &#123; &#125; 변화감지기의 구체적인 모습은?런타임에 컴포넌트의 타입스크립트와 html를 합친 componentName.ngFactory.js 클래스가 만들어진다. 이 클래스의 메소드인 detectChangeInternal를 활용해 각 컴포넌트는 변화 감지를 수행한다고 하는데..ChangeDetectorRef 디펜던시를 컨스트럭터에 주입하면 각 컴포넌트의 변화감지기를 참조할 수 있다. 12(생략)constructor (private cd : ChangeDetectorRef) &#123;...&#125; 변화 감지기를 선택적으로 껐다 켤 수도 있다. Input엘리먼트를 가지고 있는 컴포넌트는 외부 변화 감지를 하진 않아도 Input에서 나오는 value값을 다른 컴포넌트에 전달할 필요가 있다. Input value를 받는 컴포넌트의 경우도 마찬가지. 이런 경우에는 input value값이 달라지는 경우에만 변화감지기를 잠깐 열어둘 수도 있다. HTTP API로 옵저버블 타입의 Input value를 많이 주고 받는데 이 방법을 활용해 볼 필요가 있다고 생각했다. 1234567891011121314@Component()class CartBadgeCmp &#123; @Input() addItemStream : Observable&lt;any&gt; counter = 0; constructor(privated cd: ChangeDetectorRef)&#123;&#125; ngOnInit() &#123; this.addItemStream.subscribe(&#123; this.counter++; // 상태 변화가 발생 this.cd.markForCheck(); // 변화가 발생한 경우에만 자신의 위치에서 루트 컴포넌트까지 감지기를 켜둔다. &#125;) &#125;&#125; 이처럼 변화감지를 조절할 수 있는 방법은 다양하다. 적절한 변화감지 통제가 일어나면 매 프레임마다 처리할 코드가 많은 브라우저의 입장에선 렌더링 시간이 줄어들기 때문에 보다 부드러운 웹 화면을 만들 수 있다.(추후 브라우저 렌더링 포스팅) NgZone : 언제 끝날 지 모르는 비동기를 추적한다동기 함수와 다르게 비동기 함수는 기본적으로 언제 작업이 끝날 지 알기 어렵다. 변화가 일어난 순간을 정확히 감지하고 거기에 대응해야 하는 앵귤러의 입장에선 이를 다루기가 쉽지 않다. 그래서 비동기 함수의 시작과 끝을 정확히 파악해주는 것이 zone.js다. zone.js가 있어서 비동기 함수를 코딩할 때마다, 앵귤러에게 일일이 함수의 변화 순간을 알려 주지 않아도 된다. 직접 변화 감지를 통제 하고 싶다면, NgZone이라는 모듈을 활용해서 관련 메소드를 쓰면 된다. 참고) https://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/16 pascal precht의 발표 슬라이드. https://youtu.be/X0DLP_rktsc 1번 ppt를 가지고 발표하는 pascal precht. https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html 또 pascal precht의(…) 사이트. 변화 감지와 관련된 앵귤러 객체/메소드는 다음 포스팅에 올릴 예정","categories":[],"tags":[{"name":"앵귤러2+, change detection","slug":"앵귤러2-change-detection","permalink":"https://wonn223.github.io/tags/앵귤러2-change-detection/"}]},{"title":"CSS 이해하기 (1) position, z-index가 만든 쌓임 순서/ 쌓임 맥락","slug":"zindex","date":"2018-01-14T09:38:02.000Z","updated":"2018-01-15T03:20:56.000Z","comments":true,"path":"2018/01/14/zindex/","link":"","permalink":"https://wonn223.github.io/2018/01/14/zindex/","excerpt":"","text":"css 작업을 하다 보면 특정 요소를 다른 요소보다 앞에 두고 싶을 때가 있다. 그럴 땐 먼저 position : relative | absolute로 요소를 움직여본다. 작동이 안 되는 것 같으면 z-index를 활용했는데, 문제는 z-index마저 먹히지 않는 상황이 있다는 것(…). 그 이유를 찾아 보다가 쌓임 맥락(stacking context)이란 것을 알게 되었다. 쌓임맥락HTML문서가 DOM에서 렌더링 트리로 변할 때까지 트리의 렌더 오브젝트(DOM에선 노드)는 문서에 적힌 위계를 그대로 가지고 여러 개의 층(stack)을 이룬다. 스택에서 볼 수 있는 층 간의 위계를 쌓임 순서/위계(stacking order)라고 하며 각 층에서 오브젝트들이 저마다 형성한 위계를 쌓임 맥락(stacking context)이라 한다. 층이 쌓이는 순서는 기본적으로 HTML문서에 선언된 위치에 따라 결정되지만, 레이어에 변화를 일으키는 css프로퍼티(position, z-index)에 따라 그 순서가 달라진다. 이는 브라우저의 렌더링 작업에도 영향을 미친다. (브라우저 렌더링 작업에 관한 글은 따로 정리.) philpwalton의 글 중.. 어떤 엘리먼트의 쌓임 맥락(stacking context)이 쌓임 순서(stacking order) 상 가장 낮은 곳에 있는 경우엔 z-index의 값이 1억이라도, 쌓임 순서가 높은 엘리먼트보다 화면 앞에 위치할 수 없다. 쌓임 맥락을 만드는 요소들 문서의 뿌리 요소 엘리먼트 html // 예제 position 속성이 있고, z-index를 auto가 아닌 정수값으로 지정한 엘리먼트 // 예제 opacity를 1보다 낮게 설정한 엘리먼트 z-index를 정수값 지정했고 flex속성을 가진 엘리먼트 z-index를 정수값 || auto이고, position:fixed를 가진 엘리먼트 예제우선 z-index는 요소에 position 프로퍼티가 있을 때만 유효하다. position 속성이 없으면 z-index를 높여도 기존의 화면이 달라지지 않는다. 123456789101112131415161718192021222324#box_1 &#123; width: 200px; height: 200px; position: relative; z-index: 99; background: goldenrod;&#125;#box_2 &#123; width: 200px; height: 200px; position: relative; z-index: 500; margin-top: -72px; background: darkgreen;&#125;#box_3 &#123; width: 200px; height: 200px; position: relative; z-index: 1; background: darkcyan;&#125; 왼쪽이 세 개의 id에 position과 z-index 모두 적용했을 때 모습이다. 초록색 박스(div_2)가 금색 박스보다 z-index가 높고 margin-top속성을 가지고 있어서 금색 박스(div_1)를 덮었다. 오른쪽의 경우는 초록색 박스의 position 속성을 껐을 때다. z-index 속성이 무효화되고, 초록색 박스의 margin-top 값만큼 청록색 박스가 끌려 올라간 것을 알 수 있다. position 속성이 없어진 초록색 박스는 1,3번 박스와 다른 스택 맥락을 갖게 되었기 때문에 자신의 z-index는 자신이 위치한 새로운 쌓임 맥락에서만 유효하다. 같은 쌓임 맥락에 있는 요소들 끼리의 쌓임 순서가 결정되는 법Smashing magazine에서 알려 준 기본 stack 형성 순위는 다음과 같다.5번으로 갈수록 화면 앞으로 나온다. 배경과 보더를 형성하는 엘리먼트 음수 값을 가진 css 프로퍼티가 있는 엘리먼트( margin : - 10px ) float이 아니며 display : block인 엘리먼트 float인 엘리먼트 인라인 속성 엘리먼트(6. 포지션 | z-index 속성이 있는 엘리먼트) 부모의 쌓임 맥락과 자식의 쌓임 맥락은 또 다르다.부모와 자식은 별개의 맥락을 형성하고, 자식은 부모의 쌓임 맥락을 따르게 된다. 12345678910// html&lt;div id=&quot;box1&quot;&gt; &lt;span class=&quot;red&quot;&gt;Red&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt; &lt;span class=&quot;green&quot;&gt;Green&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span class=&quot;blue&quot;&gt;Blue&lt;/span&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// css.red, .green, .blue &#123; position: absolute; width: 100px; color: white; line-height: 100px; text-align: center;&#125;.red &#123; z-index: 999; top: 20px; left: 20px; background: red;&#125;.green &#123; z-index : 1000; // green이 red보다 z-index가 높다. // span 요소가 형성한 쌓임 맥락에선 green이 화면 제일 앞쪽에 위치한다. 하지만.. top: 60px; left: 60px; background: green;&#125;.blue &#123; top: 100px; left: 100px; background: blue;&#125;#box1 &#123; position : relative; z-index : 1000; // red 부모 요소의 z-index가 green 부모 요소의 것보다 값이 크다. // 그래서 red가 화면 제일 앞쪽에 위치한다.&#125;#box2 &#123; position: relative; z-index : 999;&#125; Codepen으로 확인하기 display:float인 경우 포지션이 지정된 엘리먼트와 그렇지 않은 엘리먼트 사이에 위치한다. 개념을 접하고 나서 [philpwalton의 글 중..] …If you’re setting a z-index of a billion on an element and it’s not moving forward in the stacking order, take a look up its ancestor tree and see if any of its parents form stacking contexts 만약 어떤 요소에 z-index를 줬는데 변화가 일어나지 않았다면 position 프로퍼티가 선언되었는지를 확인하거나, 부모 요소에 쌓임 맥락이 형성되어 있는지를 확인하면 원인을 파악할 수 있겠다는 생각이 들었다. 1) https://coding.smashingmagazine.com/2009/09/the-z-index-css-property-a-comprehensive-look/ &gt; smashingmagazine에서 제공하는 쌓임맥락 설명. 코드 예제와 z-index 적용된 사이트를 소개하고 있다. 2) https://mytory.net/archives/10997 &gt; 쌓임 맥락에 관한 기본적인 내용을 번역해 준 사이트 3) https://developer.mozilla.org/ko/docs/Web/CSS/Understanding_z-index/The_stacking_context &gt; MDN에서 제공하는 쌓임 맥락 이야기 4) https://gitlab.com/SeunghoLee/my-markup-project/issues/2 &gt; 정리를 깔끔하게 해주신 개발자님 깃북","categories":[],"tags":[{"name":"z-index, css, 쌓임맥락, stacking context, position","slug":"z-index-css-쌓임맥락-stacking-context-position","permalink":"https://wonn223.github.io/tags/z-index-css-쌓임맥락-stacking-context-position/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-13T09:59:07.000Z","updated":"2018-01-13T09:59:07.000Z","comments":true,"path":"2018/01/13/hello-world/","link":"","permalink":"https://wonn223.github.io/2018/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
{"meta":{"title":"seokwon","subtitle":"Seokwon}.github.io","description":"seokwon's blog","author":"seokwon","url":"https://wonn223.github.io"},"pages":[],"posts":[{"title":"immutable한 객체 만들기 - Immutable.js의 Map","slug":"immutable","date":"2018-01-23T10:48:25.000Z","updated":"2018-01-23T10:53:48.000Z","comments":true,"path":"2018/01/23/immutable/","link":"","permalink":"https://wonn223.github.io/2018/01/23/immutable/","excerpt":"","text":"https://developers.redhat.com/blog/2017/01/17/data-encapsulation-vs-immutability-in-javascript/ immutable한 객체를 만드는 법을 소개한 글인데, 대략적으로 해석해봤다. ES6에서 나온 데이터구조, 클로저, 그리고 위에서 사용한 immutable.js 등 변하지 않는 개체를 만드는 방법이 많은 것 같다. 방법마다 어떤 장,단점이 있는지 잘 정리해봐야겠다. Object.freeze123456789101112131415class Product &#123; constructor(name) &#123; this.name = name; this.id = 20000; Object.freeze(this); &#125;&#125;const widget = new Product(&apos;widget&apos;)console.log(widget); // Product &#123; name: widget, id: 20000 &#125;widget.name = &apos;coffee&apos;;console.log(widget); // Product &#123; name: undefined, id: 20000 &#125;, 얼려서 변환이 안 됨 만약 this.price = getPrice(); 처럼 값이 자주 달라지는 프로퍼티가 존재할 수 있다. 이 프로퍼티가 참조값을 가지고 있다면, 기존 클래스 인스턴스의 price프로퍼티에 많은 변동이 생길 수 있다. 그래서 Object.assign()으로 price를 immutable한 값으로 만든다. 1234567891011121314151617181920class Product &#123; constructor(name) &#123; this.name = name; this.id = 20000; this.price = getPrice(); Object.freeze(this); &#125; updatePrice() &#123; return Object.assign(new Product(), this, &#123; price : getPrice()&#125; ) &#125;&#125;const widget = new Product();widget.updatePrice();// Type Error. Cannot assign to read only property // new Product() 결과가 freeze의 영향으로 읽기 전용이 되기 때문에 에러가 발생한다. 다른 방법이 필요하다. 얼린 객체를 만드는 공장을 하나 짓는다.123456789101112131415161718192021222324252627282930&lt;!-- 1. Product와 똑같은 프로퍼티를 지닌 객체를 만들고 얼린다. --&gt;const productFactory = (name,price) =&gt; &#123; return Object.freeze(&#123;name, price&#125;); &#125;&lt;!-- 1-2. 얼린 객체를 변수에 할당한다. --&gt;const newWidget = productFactory(&apos;acme widget&apos;, 1.00);console.log(newWidget); // &#123; name: &apos;acme widget&apos;, price: 1 &#125;&lt;!-- 2. newWidget을 object.assign 소스 인자로 던져주고 빈 객체에 복사된 결과물을 다시 얼린다. --&gt;const updatePrice = product =&gt; &#123; return Object.freeze(Object.assign(&#123;&#125;, product, &#123; price : product.price * 1.04 &#125;) );&#125;const UpdateNewWidgt = updatePrice(newWidget);console.log(UpdateNewWidgt); // &#123; name: &apos;acme widget&apos;, price: 1.04 &#125; 디스트럭쳐링을 활용해서 서로 다른 객체의 값을 합치는 것처럼, 여기서도 빈 객체에 기존의 인스턴스와 price 객체를 object.assign으로 합하고 있다. 단 이 방법은 여러 중첩된 객체를 가지고 있는 프로퍼티가 있을 땐 비효율적이다. 프로퍼티 내부의 프로퍼티를 바꾸고 나서 중첩된 스코프마다 일일이 Object.freeze()를 해줘야하기 때문이다. Immutable.js 활용하기처음부터 프로퍼티를 초기화 할 때 Immutable한 객체를 할당하면 위와 같은 현상을 미리 예방할 수 있다. 이를 도와주는 패키지가 Immutable.js다. npm에서 immutable 패키지를 설치하고 새 파일을 연 다음, 얼린 객체를 생성할 모듈을 만든다. 아래에서는 Immutable의 데이터 구조 유형 중 하나인 Map을 사용했다.123456789&lt;!-- immutable.js --&gt;const Immutable = require(&apos;immutable&apos;);const factory = (name, price) =&gt; &#123; // immutable한 Map으로 데이터 구조가 바뀜 return Immutable.Map(&#123;name, price&#125;);&#125;module.exports = exports = &#123; factory &#125;; 1234567891011121314151617&lt;!-- product.js --&gt;const Product = require(&apos;./immutable.js&apos;);const widget = Product.factory(&apos;acme widget&apos;, 1.00);console.log(widget);// Map &#123; &quot;name&quot;: &quot;acme widget&quot;, &quot;price&quot;: 1 &#125;&lt;!-- widget에 Map.set()으로 정보 업데이트 --&gt;const updatedWidget = widget.set(&apos;price&apos;, 1.04);console.log(updatedWidget);// Map &#123; &quot;name&quot;: &quot;acme widget&quot;, &quot;price&quot;: 1.04 &#125;console.log(widget);// Map &#123; &quot;name&quot;: &quot;acme widget&quot;, &quot;price&quot;: 1 &#125; 초기값을 설정한 변수 widget에 set을 사용했지만 widget의 값은 달라지지 않았다. Map.set(‘key’)으로 반환 받은 객체는 widget의 복사 객체기 때문이다. Immutable.js에서 Map을 가진 객체는 자신의 값까지 포함해서 하나의 키가 될 수 있다.&lt;!-- immutable 모듈 로딩 --&gt; const Immutable = require(&apos;immutable&apos;); // &lt;!-- Map 초기화 후 할당 --&gt; const person = Immutable.Map({ key1: &apos;hello&apos;, key2: &apos;world&apos; }) let cloned_person = Immutable.Map(); // &lt;!-- person 객체를 키로 사용하기 --&gt; cloned_person = cloned_person.set(person, &apos;객체 전체가 키가 됩니다.&apos;) console.log(cloned_person); // Map { {&quot;key1&quot;:&quot;hello&quot;,&quot;key2&quot;:&quot;world&quot;}: &quot;객체 전체가 키가 됩니다.&quot; } console.log(cloned_person.get(person)); // 객체가 키가 됩니다. 출처 https://blog.jscrambler.com/immutable-data-immutable-js/ Immutable의 데이터 구조는 Map외에 List, Stack, Set, Record 등 다양하다. 아래의 사이트에서 각 데이터 구조를 예시와 함께 확인할 수 있다. https://velopert.com/3354 Map과 메소드를 활용한 immutable 객체 생성을 보여준다. immutable.js의 Map은 자바스크립트 객체보다 객체 안의 객체 프로퍼티에 보다 쉽게 접근할 수 있는 것을 확인할 수 있다.","categories":[],"tags":[{"name":"immutable, immutable.js, Object.freeze","slug":"immutable-immutable-js-Object-freeze","permalink":"https://wonn223.github.io/tags/immutable-immutable-js-Object-freeze/"}]},{"title":"자바스크립트 이해하기 - 프로퍼티와 Enumerable","slug":"enumerable","date":"2018-01-22T09:33:55.000Z","updated":"2018-01-23T06:56:34.000Z","comments":true,"path":"2018/01/22/enumerable/","link":"","permalink":"https://wonn223.github.io/2018/01/22/enumerable/","excerpt":"","text":"객체 안에 선언한 프로퍼티는 키와 값으로만 이루어진 개념이라 생각했었는데 어트리뷰트까지 가지고 있었고, 그 종류도 프로퍼티 성격에 따라 나뉜다는 걸 알았다. configurable/writable/enumerable 등등 여러 어트리뷰트 중에서 Enumerable 어트리뷰트를 좀더 찾아봤다. 프로퍼티 별 어트리뷰트 : 데이터 프로퍼티와 접근자 프로퍼티1) 데이터 프로퍼티 value와 writable 어트리뷰트를 가지고 있다. value는 프로퍼티가 가지고 있는 값을 말한다. writable은 재할당 가능 여부를 알려주는 어트리뷰트다. 2) 접근자 프로퍼티 게터와 세터가 여기에 해당한다. 3) 데이터 프로퍼티와 접근자 프로퍼티가 모두 가지는 것 enumerable/configurable 어트리뷰트가 있다. enumerable은 for 루프나 Object.keys()로 접근 시 프로퍼티의 노출가능성을 알려주는 어트리뷰트다. Enumerable기본적으로 프로퍼티의 enumerable flag는 true로 설정되어 있다고 한다.1234567891011121314151617const obj = &#123; purposeOfLife: 42&#125;&lt;!-- purposeOfLife 프로퍼티와 관련된 어트리뷰트를 보여준다. --&gt;console.log(Object.getOwnPropertyDescriptor(obj, &apos;purposeOfLife&apos;));&#123; value = 42, writable = true, enumerable = true, configurable = true&#125;&lt;!-- 어트리뷰트 중 enumerable만 확인하고 싶다면 --&gt;console.log(obj.propertyIsEnumerable(&apos;purposeOfLife&apos;)); // true 최초에 Enumerable 값이 false로 되어 있는 경우 : 내장된 객체의 프로퍼티는 Non-Eunmerable이다. 123객체 prototype의 프로퍼티 toString메소드 체크console.log(&#123;&#125;.propertyIsEnumerable(&apos;toString&apos;)); // false Object.defineProperty()메소드로 오브젝트 프로퍼티를 정의내리면, enumerable 기본값이 false가 되어있다. 123456789101112131415예제)age란 프로퍼티를 가진 man 객체에 fullname 프로퍼티를 추가시기키let man = &#123;age : 18&#125;;Object.defineProperty(man, &apos;fullname&apos;, &#123; value : &quot;John Resig&quot;&#125;)console.log(man.fullname); // John Resigconsole.log(Object.keys(man)); // [ &apos;age&apos; ]-&gt; non-enumerable인 프로퍼티 fullname은 나오지 않음. -&gt; 단, enumerable : true를 명시적으로 입력하면 기본값이 사라진다. Object.defineProperty()로 어트리뷰트 바꾸기 메소드의 세 번째 인자로 서술자 객체라는 것이 들어가는데, 이 객체 안에 프로퍼티 어트리뷰트가 담겨 있다.1234567891011121314let man = &#123;age : 18, fullname: &apos;unknown&apos;&#125;;// &lt;!-- 인자 1 : 프로퍼티가 있는 객체, 인자2 : 타겟 프로퍼티 인자3 : 서술자 객체 --&gt;man = Object.defineProperty(man, &apos;fullname&apos;, &#123; value : &quot;BrendanEich&quot;, configurable : false&#125;)&lt;!-- value 변경 확인 --&gt;console.log(man); // &#123; age: 18, fullname: &apos;BrendanEich&apos; &#125;&lt;!-- configurable 적용 확인 --&gt;console.log(delete man.fullname); // false Object.getOwnPropertyDescriptor()로 프로퍼티 어트리뷰트 조회하기1234let man_descriptor = Object.getOwnPropertyDescriptor(man, &apos;fullname&apos;);console.log(man_descriptor.value); // Brendan Eichconsole.log(man_descriptor.configurable); // false; Enumerable : true에 영향을 받는 메소드프로퍼티가 Enumerable flag의 값을 false로 가지고 있다면, JSON.stringify메소드로 검색되지 않는다. 123456789101112131415let obj = &#123; name: &apos;scoth.io&apos;, name_nonenum: &apos;scoth.co.kr&apos;&#125;Object.defineProperty(obj, &apos;name_nonenum&apos;, &#123; enumerable: false&#125;)console.log(obj.propertyIsEnumerable(&apos;name_nonenum&apos;)); // falselet jsonObj = JSON.parse(JSON.stringify(obj));console.log(jsonObj); // &#123; name: &apos;scoth.io&apos; &#125; Enumerable: false면 객체 프로퍼티를 모아서 보여주는 Object.keys()에서 검색되지 않는다.12345678910let man = &#123;age : 18, fullname: &apos;unknown&apos;&#125;;man = Object.defineProperty(man, &apos;fullname&apos;, &#123; value : &quot;Brendan Eich&quot;, enumerable : false, configurable : false&#125;)console.log(Object.keys(man)); // [ &apos;age&apos; ] non-eumerable인 프로퍼티까지 보려면 Object.getOwnPropertyNames(obj)를 사용한다. 1console.log(Object.getOwnPropertyNames(man)); // [ &apos;age&apos;, &apos;fullname&apos; ] for in 문에서 검색되지 않는다.123for ( let v in man ) &#123; console.log(v); // age&#125; 언제 Enumerable 어트리뷰트를 고려하나? private한 프로퍼티를 원할 때?위 예시에서 보듯 JSON.stringfy()나 for루프, 프로퍼티 접근 메소드에서 non-enumerable은 노출되지 않기 때문에, private한 프로퍼티를 만들고 싶을 때 enumerable 어트리뷰트를 사용하면 될 것이란 생각이 들었다. 하지만 Dr. Axel Rauschmayer는 완전한 private 프로퍼티가 안 된다고 말하고 있다. 읽기 전용이 되지만 getter로 enumerable한 프로퍼티에 접근할 수 있고, 여전히 프로퍼티 접근이 가능한 메소드가 있어서 복사를 할 때 non-enumerable프로퍼티는 복사가 안 되서 등 그래서 보다 더 안전한 은닉화를 원한다면 클로저나 WeakMap,’Symbol’과 같은 개념을 사용한다. WeakMap12345678910111213141516171819const privates = new WeakMap();class Product &#123; constructor(name) &#123; console.log(this); // Product &#123;&#125; this.name = name; privates.set(this, &#123; id: 234087 &#125;); &#125; related() &#123; return console.log(privates.get(this)); &#125;&#125;const tea = new Product(&apos;coffee&apos;);tea.related(); // &#123; id: 234087 &#125; 1234567891011121314const ID = Symbol(&apos;id&apos;);class Product &#123; constructor (name) &#123; this.name = name; this[&apos;id&apos;] = 234087; related () &#123; return console.log(this[&apos;id&apos;]); &#125; &#125; const tea = new Product(&apos;coffee&apos;) tea.related(); // 234087 Symbol은 Object.getOwnPropertyNames()에 드러나지 않지만 Reflect.ownKey()s나 Object.getOwnPropertySymbols()에서는 노출이 된다.프로퍼티 노출은 되지만 접근은 불가능. 12345678910111213141516171819202122232425262728293031323334namespace Validation &#123; export interface StringValidator &#123; isAcceptable(s: string): boolean; &#125;&#125;const lettersRegexp = /^[A-Za-z]+$/;const numberRegexp = /^[0-9]+$/;export class LettersOnlyValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return letterRegexp.test(s); &#125;&#125; export class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];let validator &#123; [s:string]= Validation.StringValidator &#125; = &#123;&#125;;validators[&quot;Zip code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();for (let s of strings) &#123; for (let name in validators) &#123; console.log(); &#125;&#125; 출처https://johnresig.com/blog/ecmascript-5-objects-and-properties/ ES5 새 기능 중 Object와 관련된 새 기능을 소개해준다. 프로퍼티와 서술자(Descriptors) 설명도 있음. http://2ality.com/2015/10/enumerability-es6.html enumerable에 전반적인 내용이 담겨있다. http://boycoding.tistory.com/38 [소년코딩] 서술사 객체 설명과 예시를 본 사이트.","categories":[],"tags":[{"name":"es5, enumerable, 자바스크립트, 프로퍼티","slug":"es5-enumerable-자바스크립트-프로퍼티","permalink":"https://wonn223.github.io/tags/es5-enumerable-자바스크립트-프로퍼티/"}]},{"title":"자바스크립트 - 객체 복사하기","slug":"copy","date":"2018-01-21T09:38:43.000Z","updated":"2018-01-22T09:40:23.000Z","comments":true,"path":"2018/01/21/copy/","link":"","permalink":"https://wonn223.github.io/2018/01/21/copy/","excerpt":"","text":"객체를 참조하는 경우가 많아지면 제어 흐름에 어려움을 겪는다는 이야길 많이 접하고 있다. 제어흐름을 신경써야할 만큼 큰 규모의 웹 앱을 만들어보지 않았지만, 객체의 참조를 피할 수 있는 법을 알아봤다. 새 객체 만들기 : Object.create(proto[, propertiesObj])인자 proto : 새롭게 만들어질 객체의 프로토타입이 될 객체 1234567891011121314const person = &#123; name: &apos;&apos;, type : &quot;인간&quot;, getName : function() &#123; return this.name; &#125;&#125;// 복사let man1 = Object.create(person);man1.name = &apos;man 1&apos;;console.log(man1.type);console.log(man1.getName()); Object.assign(target, …sources)sources : target의 일원이 될 여러 객체를 일컫는다. 객체 안에 enumerable한 속성이 있으면 그 속성을 target객체로 복사한다. 주의할 점은 객체의 프로퍼티가 객체를 참조하고 있으면, target객체로 참조의 복사가 일어난다. 123456789101112131415161718192021let obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;let newObj = Object.assign(&#123;&#125;, obj);console.log(newObj); //obj와 똑같은 형태가 만들어짐.newObj.a = 10;console.log(newObj.a); // 10 console.log(obj.a); // 1&lt;!-- newObj만 달라짐. 프로퍼티 값이 immutable이므로 --&gt;&lt;!-- 하지만 --&gt;newObj.b.c = 30;console.log(obj.b.c); // 30 obj도 객체의 프로퍼티가 달라졌다. 기존의 obj.b가 가진 값이 원시값이 아니라 mutable한 객체였기 때문에, newObj.b와 obj.b가 같은 메모리 주소를 가리키고 있는 상태다. 즉, obj.b가 가리키고 있는 메모리 주소의 참조가 newobj.b로 옮겨진 것. 대안 JSON.parse(JSON.stringify(object))를 활용한다. 123456789101112let obj2 = &#123; a: 1, b: &#123; c: 2 &#125;&#125;let newObj2 = JSON.parse(JSON.stringify(obj2));newObj2.b.c = 20;console.log(obj2); // &#123; a: 1, b: &#123; c: 2 &#125; &#125;console.log(newObj2); // &#123; a: 1, b: &#123; c: 20 &#125; &#125; 단, JSON.parse는 메소드 복사가 안 된다.. 123456789101112131415161718//scoth.io 예제let obj3 = &#123; name: &apos;scoth.io&apos;, exec: function exec()&#123; return true; &#125;&#125;let method1 = Object.assign(&#123;&#125;, obj3);let method2 = JSON.parse(JSON.stringify(obj3));console.log(method1);// &#123; name: &apos;scoth.io&apos;, exec: [Function: exec] &#125;console.log(method2); // &#123; name: &apos;scoth.io&apos; &#125; 함수객체가 복사되지 않는 이유는 JSON에서 함수를 데이터로 보지 않기 때문이다. (함수 제외)오브젝트, 스트링, 넘버, 배열, 불리언을 제외한 유형은 인코딩 과정에서 무시된다고 한다. JSON메소드를 사용하지 않고 아래의 링크처럼 직접 깊은 복사를 구현한 함수를 쓰기도 한다. https://jsperf.com/deep-copy-vs-json-stringify-json-parse ES6 스프레드(…) 연산자 사용 123456789101112131415161718192021// 스프레드 연산자는 새 객체에 enumerable한 객체를 할당하는 데 사용한다.const original = &#123; a : &#123; b: 1&#125;&#125;;const falseCopy = &#123;...original&#125;;falseCopy.a.b = 10;console.log(original); // &#123; a: &#123; b: 10 &#125; &#125;console.log(falseCopy); // &#123; a: &#123; b: 10 &#125; &#125;const original = &#123; a: &#123; b: 1 &#125;, anotherRandomValue: 42 &#125;;// Always put the original with the spread operator firstconst falseCopy = &#123; ...original, a: &#123; b: 2 &#125; &#125;;console.log(falseCopy) // logs &#123; a: &#123; b: 2 &#125;, anotherRandomValue: 42 &#125;console.log(original) // logs &#123; a: &#123; b: 1 &#125;, anotherRandomValue: 42 &#125; 복사가 되지 않는 것들 : 프로토타입 체인에 있거나 non-enumerable한 객체123456789101112131415161718192021222324252627282930let someObj = &#123; a: 2&#125;// someObj는 obj의 프로토타입 객체가 되었으므로 복사되지 않음.console.log(obj.__proto__); // &#123; a : 2&#125;let obj = Object.create(someObj, &#123; b : &#123; value: 2, // enumerable : false이므로 복사되지 않는다. &#125;, c : &#123; value: 3, enumerable: true &#125;&#125;);console.log(Object.getOwnPropertyDescriptor(obj, &apos;b&apos;));&#123; value: 2, writable: false, enumerable: false, configurable: false &#125;let objCopy = Object.assign(&#123;&#125;, obj)console.log(objCopy); // &#123; c : 3 &#125; 프로퍼티가 enumerable한 성격인지 확인하고 싶다면, Object에 내장된 getOwnPropertyDescriptor나 propertyIsEnumerable()란 메소드를 사용한다. 객체의 프로퍼티를 데이터라고 하고, 데이터에 접근하는 권한을 가진 것을 가리켜 접근자라고 한다.","categories":[],"tags":[{"name":"깊은 복사, 얇은 복사, deep copy, 참조, 참조 복사","slug":"깊은-복사-얇은-복사-deep-copy-참조-참조-복사","permalink":"https://wonn223.github.io/tags/깊은-복사-얇은-복사-deep-copy-참조-참조-복사/"}]},{"title":"Javascript 이해하기 - 일을 분담시키는 비동기 로직과 스레드","slug":"async","date":"2018-01-19T10:52:47.000Z","updated":"2018-01-22T09:40:12.000Z","comments":true,"path":"2018/01/19/async/","link":"","permalink":"https://wonn223.github.io/2018/01/19/async/","excerpt":"","text":"브라우저는 기본적으로 메인 스레드라는 스레드 하나만 사용한다. 처리할 게 많아도 스레드는 한 번에 하나씩만 처리할 수 있다. 그동안 다른 작업은 큐에 있으면서 스레드의 처리를 기다리는데, 이 때 스레드가 작동을 멈춰야 하는 경우가 있다. 처리해야 하는 일이 동기적인 성격을 가진 경우인데(동기적으로 서버 데이터 불러오기), 이 때 스레드는 처리해야할 값이 올 때까지 가만히 기다리고 있어야 한다. 자연스레 큐에 있는 일의 대기시간도 늘어가기 때문에 비동기 기능를 적절히 사용해서 스레드의 작업 효율을 높여야 한다. 방법 : 비동기 API를 활용한다브라우저가 제공하는 기본 비동기 API setTimeOut: 특정 시간 이후의 프레임에 코드를 적재함 setInterval: 특정 간격의 프레임마다 코드를 적재함 requestAnimationFrame : 프레임 간의 시간 차를 확인해보고 코드를 넘겨야할 것 같다면, 다음 렌더링 타임으로 코드를 이동시킨다. DOM 이벤트 리스너 : dom에 이벤트를 달아놓고 이벤트가 생길 때 마다 코드를 적재함. XHR(AJAX) : HTML5 Web Worker, HTML GeoLocation, IndexedDB 등이 있다. DOM이벤트를 활용해서 비동기로 처리되는 일이 끝나면, DOM 이벤트 리스너를 활용해 완료한 일을 만질 수 있도록 제어권을 준다. 비동기가 가진 단점 : 서브루틴의 존재와 오류 처리.처리된 값을 받고 수정을 하는 서브루틴이 여러 개가 있으면, 스택 메모리도 쌓이고 가독성도 떨어진다. 또 서브루틴의 서브루틴을 실행시키는 도중에 오류가 생길 땐, 어디서 오류가 시작되었는지 파악하기 어렵다. 그래서 아래와 같이 에러 처리를 함수를 넣는다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- 기본적인 오류 처리 방법 : 에러를 잡는 콜백 함수를 하나 더 만든다. --&gt;let obj = getData( (res) =&gt; &#123; console.log(res);&#125;, (err) =&gt; &#123; thorw Error(&apos;err&apos;); &#125;)&lt;!-- 하지만 getData 안에 또 세부 정보를 얻는 getLocation()이 있다면? --&gt;let obj = getData( (res) =&gt; &#123; console.log(res); // getData성공 &#125; getLocation(location) &#123; console.log(location); // getLocation 성공 &#125; , fucntion(err) &#123; console.log(err); // getLocation실패 &#125;, fucntion(err) &#123; console.log(err); // getData실패 &#125; );// 복잡해진다. 콜백 헬&lt;!-- 프로미즈 사용 --&gt;let Promise = new Promise(resolve, reject) &#123; resolve(&apos;성공할 때 나올 메시지&apos;); reject(&apos;실패할 때 나올 메시지&apos;);&#125;Promise.then( (res) = &gt; &#123; console.log(res) // &apos;성공할 때 나올 메시지&apos;;&#125;).then(&apos;2번 연속 성공&apos;).cathch( (err) =&gt; &#123; console.log(&apos;3연속 실패&apos;);&#125;) // 콜백의 콜백을 보다 깔끔하게 표현한다.// catch문이 .then문으로 처리하는 도중에 생길 수 있는 오류를 잡아준다.&lt;!-- 하지만 스레드가 코드를 한 번 지나가면 끝이다. 코드에 쓴 만큼만 연속적으로 값을 가지고 처리한다. --&gt;&lt;!-- 코드가 한번 돌아도 데이터가 계속해서 유지되는 옵저버블(추가) --&gt;``` ### 웹워커로 스레드를 더 활용한다.자바스크립트는 처음에 만들어 질 때 브라우저에서 사용자 경험을 늘리는 데 목적이 있어서 브라우저 ui를 처리하는 스레드를 하나 밖에 가질 수 없었다. HTML5가 나오면서 웹워커를 활용해 UI스레드 외에 추가적인(백그라운드) 스레드를 사용할 수 있게 됐다. 웹 워커 공간에서 DOM을 비롯해 접근할 수 없는 객체가 여러 개 있지만, 복잡한 연산을 처리해서 메인 스레드로 넘겨주면 메인 스레드가 안정적인 처리를 할 수 있다.![웹워커 단점](./비동기로직/webworker단점.png)&lt;!-- ### 비동기 결과를 받는 방법1. 이벤트 형식 &lt;!-- 다음 작업을 진행한다. --&gt; &lt;!-- processData(); --&gt; &lt;!-- 실패했을 땐 오류 보여주기 --&gt; &lt;!-- console.log(httpObejct.err); --&gt;","categories":[],"tags":[{"name":"비동기, 웹 워커, AJAX, IndexedDB, 스레드, HTML5","slug":"비동기-웹-워커-AJAX-IndexedDB-스레드-HTML5","permalink":"https://wonn223.github.io/tags/비동기-웹-워커-AJAX-IndexedDB-스레드-HTML5/"}]},{"title":"앵귤러 이해하기(2) - NgZone 적용해보기","slug":"changedetection2","date":"2018-01-17T14:57:20.000Z","updated":"2018-01-17T16:14:51.000Z","comments":true,"path":"2018/01/17/changedetection2/","link":"","permalink":"https://wonn223.github.io/2018/01/17/changedetection2/","excerpt":"","text":"불필요한 변화감지를 막고자 NgZone을 사용하는데 실제로 변화감지를 일으키는 부분에 적용해봤다. 컴포넌트 트리 안에 있는 모든 컴포넌트는 트리거에 따른 변화를 감지한다. 오늘 변화 감지를 확인한 곳은 헤더 컴포넌트의 검색창이었다. 입력칸에 검색어를 입력하면 HTTP API로 DB 데이터에 있는 검색결과를 받아 오는데 이 과정에서 컴포넌트의 변화 감지가 발생한다. 검색창의 값(검색어)이 옵저버블 이란 인터페이스를 활용하고 있다. 옵저버블 타입을 가지면 서버에 있는 데이터를 계속해서 요청하고 받을 수 있다. 검색창에 글자를 입력할 때마다 서버로 Http Get이 이뤄지는데, 이 때 특정 시간까지 글자를 모아 서버에 검색어를 전달한다. 검색어를 전달하면 서버에서 검색결과를 주는데 이 과정에서 변화감지가 많이 일어나고 있었다. NgZone.runOutsideAngular()변화감지를 줄이려면 검색결과가 나오기 전까지 검색 과정의 작업을 앵귤러가 인식하지 못해야한다. 앵귤러 바깥 공간에서 검색어를 서버에 전달하고, 검색결과를 다시 앵귤러 공간으로 가지고 오는 방법이 runOutsideAngular다. 이 메소드를 검색결과를 가져오는 메소드에 적용시켜봤다. 앵귤러 바깥에서 처리된 값을 다시 앵귤러 영역(zone)에 적용시키려고 subscribe구독 시 run()메소드를 사용했다. 이 안에서 검색결과 참조값을 프로퍼티에 할당했다. 변화 감지를 줄이려고 객체를 참조하지 않고 변하지 않는 값(immutable)을 사용하기도 한다. immutable한 값을 사용하면 참조로 인한 예기치 않은 변동성을 예방할 수 있고, 값을 새로 복사할 때만 변화감지가 발생하기 때문이다. 이렇게 넣어본 다음 개발자 도구를 활용해 차이점이 있는지 확인해봤다. 확인 결과, 검색어를 입력을 마친 순간까지는 차이가 없었고, 검색 결과를 받아오는 부분에서 미세한 차이가 발생했다. 작업 시간만을 보면 스크립트 부분에서 6ms(0.006)의 차이가 생겼다. 반복해서 렌더링을 체크해봤을 때도 6ms와 비슷한 값이 나왔다. 느낀 점생각보다 미세하게 차이가 나서 변화감지의 차이를 좀더 드러낼 수 있는 방법을 찾아봐야겠다. 그리고 컴포넌트를 기능 별로 좀더 세세하게 분리시켜야겠단 생각이 들었다. 헤더의 검색어 입력 이벤트를 감지해야 하는 컴포넌트가 사실 거의 없다. 검색 컴포넌트를 따로 만들어서 헤더 컴포넌트에게만 @Input을 주고,헤더 컴포넌트만 검색 컴포넌트의 변화를 감지하는 방법을 알아봐야겠다. 브라우저의 fps가 너무 높게 나왔다. 적정 프레임이 60프레임으로 알고 있는데, 600(…뭐지)이 넘는 fps가 나왔다. 개발자 도구 퍼포먼스 탭에서 결과를 보니 도큐먼트 전체에 브라우저의 레이어 작업이 적용되고 있었다. 레이어 작업을 최소화하는 방법을 알아봐야겠다.","categories":[],"tags":[{"name":"change detection, 앵귤러2, 변화 감지, ngzone","slug":"change-detection-앵귤러2-변화-감지-ngzone","permalink":"https://wonn223.github.io/tags/change-detection-앵귤러2-변화-감지-ngzone/"}]},{"title":"앵귤러 이해하기 (1) 변화 감지 - 코딩하는(?) 타이밍 잡기","slug":"changedetection","date":"2018-01-14T16:20:49.000Z","updated":"2018-01-17T15:10:34.000Z","comments":true,"path":"2018/01/15/changedetection/","link":"","permalink":"https://wonn223.github.io/2018/01/15/changedetection/","excerpt":"","text":"앵귤러로 작업을 하다 보면 클릭/키보드 같은 입력 이벤트가 발생할 때 템플릿 스타일이나 프로퍼티 값을 바꿀 때가 많다. 변화가 일어나는 타이밍이 있어야 작업을 할 수 있다는 생각이 들 정도인데, 입력 이벤트 외에 무엇이 또 변화를 일으킬까 궁금해졌다. 이 부분을 알면 코드 짜기가 수월해질 것 같았다. 변화를 일으키는 트리거(Trigger) 3가지pascal precht가 말한(변화 감지 발표를 많이 하신 분이다) 변화 트리거는 3가지다. 트리거가 만드는 변화에 맞춰 뷰나 컴포넌트의 데이터를 어떻게 처리할 지 구상하면 될 것 같다. Events(이벤트) - click, submit… XHR(서버와의 통신) - Fetching data from a remote server(HTTP.get()…) Timers(타이머) - setTimeout(), setInterval() 그 외 앵귤러에 생명 주기와 관련된 메소드가 있는데, 이 메소드의 함수 바디 안에서 모델의 변경 사항을 뷰에 반영시키는 일을 할 수 있다. 참고) 이웅재 개발자님 강의 중 https://www.inflearn.com/course-status-2/ 앵귤러의 변화 감지 방식 : ‘위에서 아래로’ 모두가 아는 변화 빨간색으로 칠해진 컴포넌트는 특정 컴포넌트에서 변화가 생겼다는 사실을 알고 있다. CD는 변화감지기의 준말. 앞서 말한 트리거로 인해 컴포넌트 변화가 일어난다. 그러면 변화가 일어났다는 사실을 컴포넌트 트리를 형성하고 있는 모든 컴포넌트가 알게 된다. 이 때 가장 먼저 소식을 접하는 컴포넌트는 최상위 루트 컴포넌트다. 루트 컴포넌트가 변화를 인식하면, 루트 컴포넌트는 자기 아래에 있는 모든 컴포넌트에게 소식을 전파한다. 다른 컴포넌트의 소식을 다 알고 싶은 게 아니라면? 감지기를 끈다 회색이 칠해진 컴포넌트는 (자기 내부의 변화를 빼곤) 다른 컴포넌트의 변화 소식을 받지 않는다. 이처럼 기본적으로 컴포넌트 전체가 변화를 감지한다. 하지만 외부 컴포넌트의 변화 하나하나를 감지하길 원치 않는 컴포넌트는 변화 감지기란 것을 꺼서 소식을 받지 않는다. 변화감지기는 런타임에 생성되는데 이걸로 템플릿에 바인딩 된 프로퍼티가 달라졌는지 감지한다. 변화 감지기를 끄고 싶으면 NgZone의 메소드 OnPush()를 사용하면 된다. 이 메소드를 사용하면 외부의 변화를 감지하지 못하고, 자신의 컴포넌트 내부에 있는 프로퍼티는 값이 바뀌지 않는 immutable이라고 선언하는 것과 같다. 12345678import &#123; Component, Oninit, ChangeDetectionStrategy &#125; from &apos;@angular/core&apos;;@Component(&#123; ... changeDetection : ChangeDetectionStrategy.OnPush&#125;)export class SomeComponent &#123; &#125; 변화감지기의 구체적인 모습은?런타임에 컴포넌트의 타입스크립트와 html를 합친 componentName.ngFactory.js 클래스가 만들어진다. 이 클래스의 메소드인 detectChangeInternal를 활용해 각 컴포넌트는 변화 감지를 수행한다고 하는데..ChangeDetectorRef 디펜던시를 컨스트럭터에 주입하면 각 컴포넌트의 변화감지기를 참조할 수 있다. 12(생략)constructor (private cd : ChangeDetectorRef) &#123;...&#125; 변화 감지기를 선택적으로 껐다 켤 수도 있다. Input엘리먼트를 가지고 있는 컴포넌트는 외부 변화 감지를 하진 않아도 Input에서 나오는 value값을 다른 컴포넌트에 전달할 필요가 있다. Input value를 받는 컴포넌트의 경우도 마찬가지. 이런 경우에는 input value값이 달라지는 경우에만 변화감지기를 잠깐 열어둘 수도 있다. HTTP API로 옵저버블 타입의 Input value를 많이 주고 받는데 이 방법을 활용해 볼 필요가 있다고 생각했다. 1234567891011121314@Component()class CartBadgeCmp &#123; @Input() addItemStream : Observable&lt;any&gt; counter = 0; constructor(privated cd: ChangeDetectorRef)&#123;&#125; ngOnInit() &#123; this.addItemStream.subscribe(&#123; this.counter++; // 상태 변화가 발생 this.cd.markForCheck(); // 변화가 발생한 경우에만 자신의 위치에서 루트 컴포넌트까지 감지기를 켜둔다. &#125;) &#125;&#125; 이처럼 변화감지를 조절할 수 있는 방법은 다양하다. 적절한 변화감지 통제가 일어나면 매 프레임마다 처리할 코드가 많은 브라우저의 입장에선 렌더링 시간이 줄어들기 때문에 보다 부드러운 웹 화면을 만들 수 있다.(추후 브라우저 렌더링 포스팅) NgZone : 언제 끝날 지 모르는 비동기를 추적한다동기 함수와 다르게 비동기 함수는 기본적으로 언제 작업이 끝날 지 알기 어렵다. 변화가 일어난 순간을 정확히 감지하고 거기에 대응해야 하는 앵귤러의 입장에선 이를 다루기가 쉽지 않다. 그래서 비동기 함수의 시작과 끝을 정확히 파악해주는 것이 zone.js다. zone.js가 있어서 비동기 함수를 코딩할 때마다, 앵귤러에게 일일이 함수의 변화 순간을 알려 주지 않아도 된다. 직접 변화 감지를 통제 하고 싶다면, NgZone이라는 모듈을 활용해서 관련 메소드를 쓰면 된다. 참고) https://pascalprecht.github.io/slides/angular-2-change-detection-explained/#/16 pascal precht의 발표 슬라이드. https://youtu.be/X0DLP_rktsc 1번 ppt를 가지고 발표하는 pascal precht. https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html 또 pascal precht의(…) 사이트. 변화 감지와 관련된 앵귤러 객체/메소드는 다음 포스팅에 올릴 예정","categories":[],"tags":[{"name":"앵귤러2+, change detection","slug":"앵귤러2-change-detection","permalink":"https://wonn223.github.io/tags/앵귤러2-change-detection/"}]},{"title":"CSS 이해하기 (1) position, z-index가 만든 쌓임 순서/ 쌓임 맥락","slug":"zindex","date":"2018-01-14T09:38:02.000Z","updated":"2018-01-22T09:37:33.000Z","comments":true,"path":"2018/01/14/zindex/","link":"","permalink":"https://wonn223.github.io/2018/01/14/zindex/","excerpt":"","text":"css 작업을 하다 보면 특정 요소를 다른 요소보다 앞에 두고 싶을 때가 있다. 그럴 땐 먼저 position : relative | absolute로 요소를 움직여본다. 작동이 안 되는 것 같으면 z-index를 활용했는데, 문제는 z-index마저 먹히지 않는 상황이 있다는 것(…). 그 이유를 찾아 보다가 쌓임 맥락(stacking context)이란 것을 알게 되었다. 쌓임맥락HTML문서가 DOM에서 렌더링 트리로 변할 때까지 트리의 렌더 오브젝트(DOM에선 노드)는 문서에 적힌 위계를 그대로 가지고 여러 개의 층(stack)을 이룬다. 스택에서 볼 수 있는 층 간의 위계를 쌓임 순서/위계(stacking order)라고 하며 각 층에서 오브젝트들이 저마다 형성한 위계를 쌓임 맥락(stacking context)이라 한다. 층이 쌓이는 순서는 기본적으로 HTML문서에 선언된 위치에 따라 결정되지만, 레이어에 변화를 일으키는 css프로퍼티(position, z-index)에 따라 그 순서가 달라진다. 이는 브라우저의 렌더링 작업에도 영향을 미친다. (브라우저 렌더링 작업에 관한 글은 따로 정리.) philpwalton의 글 중.. 어떤 엘리먼트의 쌓임 맥락(stacking context)이 쌓임 순서(stacking order) 상 가장 낮은 곳에 있는 경우엔 z-index의 값이 1억이라도, 쌓임 순서가 높은 엘리먼트보다 화면 앞에 위치할 수 없다. 쌓임 맥락을 만드는 요소들 문서의 뿌리 요소 엘리먼트 html // 예제 position 속성이 있고, z-index를 auto가 아닌 정수값으로 지정한 엘리먼트 // 예제 opacity를 1보다 낮게 설정한 엘리먼트 z-index를 정수값 지정했고 flex속성을 가진 엘리먼트 z-index를 정수값 || auto이고, position:fixed를 가진 엘리먼트 예제우선 z-index는 요소에 position 프로퍼티가 있을 때만 유효하다. position 속성이 없으면 z-index를 높여도 기존의 화면이 달라지지 않는다. 123456789101112131415161718192021222324#box_1 &#123; width: 200px; height: 200px; position: relative; z-index: 99; background: goldenrod;&#125;#box_2 &#123; width: 200px; height: 200px; position: relative; z-index: 500; margin-top: -72px; background: darkgreen;&#125;#box_3 &#123; width: 200px; height: 200px; position: relative; z-index: 1; background: darkcyan;&#125; 왼쪽이 세 개의 id에 position과 z-index 모두 적용했을 때 모습이다. 초록색 박스(div_2)가 금색 박스보다 z-index가 높고 margin-top속성을 가지고 있어서 금색 박스(div_1)를 덮었다. 오른쪽의 경우는 초록색 박스의 position 속성을 껐을 때다. z-index 속성이 무효화되고, 초록색 박스의 margin-top 값만큼 청록색 박스가 끌려 올라간 것을 알 수 있다. position 속성이 없어진 초록색 박스는 1,3번 박스와 다른 스택 맥락을 갖게 되었기 때문에 자신의 z-index는 자신이 위치한 새로운 쌓임 맥락에서만 유효하다. 같은 쌓임 맥락에 있는 요소들 끼리의 쌓임 순서가 결정되는 법Smashing magazine에서 알려 준 기본 stack 형성 순위는 다음과 같다.5번으로 갈수록 화면 앞으로 나온다. 배경과 보더를 형성하는 엘리먼트 음수 값을 가진 css 프로퍼티가 있는 엘리먼트( margin : - 10px ) float이 아니며 display : block인 엘리먼트 float인 엘리먼트 인라인 속성 엘리먼트(6. 포지션 | z-index 속성이 있는 엘리먼트) 부모의 쌓임 맥락과 자식의 쌓임 맥락은 또 다르다.부모와 자식은 별개의 맥락을 형성하고, 자식은 부모의 쌓임 맥락을 따르게 된다. 12345678910// html&lt;div id=&quot;box1&quot;&gt; &lt;span class=&quot;red&quot;&gt;Red&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt; &lt;span class=&quot;green&quot;&gt;Green&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;span class=&quot;blue&quot;&gt;Blue&lt;/span&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// css.red, .green, .blue &#123; position: absolute; width: 100px; color: white; line-height: 100px; text-align: center;&#125;.red &#123; z-index: 999; top: 20px; left: 20px; background: red;&#125;.green &#123; z-index : 1000; // green이 red보다 z-index가 높다. // span 요소가 형성한 쌓임 맥락에선 green이 화면 제일 앞쪽에 위치한다. 하지만.. top: 60px; left: 60px; background: green;&#125;.blue &#123; top: 100px; left: 100px; background: blue;&#125;#box1 &#123; position : relative; z-index : 1000; // red 부모 요소의 z-index가 green 부모 요소의 것보다 값이 크다. // 그래서 red가 화면 제일 앞쪽에 위치한다.&#125;#box2 &#123; position: relative; z-index : 999;&#125; Codepen으로 확인하기 display:float인 경우 포지션이 지정된 엘리먼트와 그렇지 않은 엘리먼트 사이에 위치한다. 개념을 접하고 나서 [philpwalton의 글 중..] …If you’re setting a z-index of a billion on an element and it’s not moving forward in the stacking order, take a look up its ancestor tree and see if any of its parents form stacking contexts 만약 어떤 요소에 z-index를 줬는데 변화가 일어나지 않았다면 position 프로퍼티가 선언되었는지를 확인하거나, 부모 요소에 쌓임 맥락이 형성되어 있는지를 확인하면 원인을 파악할 수 있겠다는 생각이 들었다. 1) https://coding.smashingmagazine.com/2009/09/the-z-index-css-property-a-comprehensive-look/ &gt; smashingmagazine에서 제공하는 쌓임맥락 설명. 코드 예제와 z-index 적용된 사이트를 소개하고 있다. 2) https://mytory.net/archives/10997 &gt; 쌓임 맥락에 관한 기본적인 내용을 번역해 준 사이트 3) https://developer.mozilla.org/ko/docs/Web/CSS/Understanding_z-index/The_stacking_context &gt; MDN에서 제공하는 쌓임 맥락 이야기 4) https://gitlab.com/SeunghoLee/my-markup-project/issues/2 &gt; 정리를 깔끔하게 해주신 개발자님 깃북","categories":[],"tags":[{"name":"z-index, css, 쌓임맥락, stacking context, position","slug":"z-index-css-쌓임맥락-stacking-context-position","permalink":"https://wonn223.github.io/tags/z-index-css-쌓임맥락-stacking-context-position/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-13T09:59:07.000Z","updated":"2018-01-13T09:59:07.000Z","comments":true,"path":"2018/01/13/hello-world/","link":"","permalink":"https://wonn223.github.io/2018/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}